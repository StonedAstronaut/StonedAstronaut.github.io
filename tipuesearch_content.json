{"pages":[{"url":"https://stonedastronaut.github.io/pages/about.html","text":"Привет. Этот блог сделан на Pelican . Здесь буду размещать всякие материалы о IT. Пример кода: @app.route ( '/' ) def index (): return render_template ( 'index.html' , posts = blog . posts )","tags":"pages","title":"О сайте"},{"url":"https://stonedastronaut.github.io/zapusk-x-prilozhenii-cherez-ssh-en.html","text":"A short command: # ssh -X <username>@<host> gedit from man ssh : -X Enables X11 forwarding. This can also be specified on a per-host basis in a configuration file. X11 forwarding should be enabled with caution. Users with the ability to bypass file permissions on the remote host (for the user's X authorization database) can access the local X11 display through the forwarded connection. An attacker may then be able to perform activities such as keystroke monitoring. Check /etc/ssh/sshd_config on the server side: # vim /etc/ssh/sshd_config for the lines below: X11Forwarding yes X11UseLocalhost no Restart the ssh srever, if you have made changes: # systemctl restart sshd.service Check /etc/ssh/ssh_config on the client side: # vim /etc/ssh/ssh_config for the lines below ForwardX11 yes ForwardX11Trusted yes © paste","tags":"linux","title":"Launch X app through ssh"},{"url":"https://stonedastronaut.github.io/kostyl-dlia-pogody-na-conky.html","text":"Погоду берем из api openweathermap . И парсим её bash скриптом. Обязательно передаем скрипту в качестве агрумента название города. Подробрнее об использовании самого api читай сайт . #!/bin/bash if [ $# -lt 1 ] || [ $# -gt 1 ] ; then echo \"error. need 1 argument\" echo \"<SCRIPT_NAME> [CITY_NAME,COUNTRY_CODE] or [CITY_CODE]\" exit fi # делаем запрос на сервер, получаем в ответ JSON RESPOND = ` curl \"http://api.openweathermap.org/data/2.5/weather?q=\" ${ 1 } \"&appid=82ec52222cfeaf622b27bb0a4bac6f31\" ` # получаем значение температуры в градусах Кельвина TEMPERATURE = $( echo ${ RESPOND } | sed -e 's/[{}]/''/g' | awk -v k = \"temp\" '{n=split($0,a,\",\"); for (i=1; i<n; i++) print a[i]}' | grep main | grep temp | sed 's/:/ /g' | awk -F \" \" '{print $3}' ) # переводим Кельвины в Цельсии TEMPERATURE = $( echo \"scale=2; $TEMPERATURE -273\" | bc | awk '{printf \"%0.2f\",$0}' ) # если вдруг вместо значения TEMPERATURE получим пустое поле, то присвоим error if [[ $TEMPERATURE == \"-273\" ]] ; then TEMPERATURE = \"error\" fi # информация об облачности INFO = $( echo ${ RESPOND } | sed -e 's/[{}]/''/g' | awk -v k = \"temp\" '{n=split($0,a,\",\"); for (i=1; i<n; i++) print a[i]}' | grep description | sed 's/:/ /g' | awk '{first = $1; $1 = \"\"; print $0}' | sed 's/\"//g' ) # получаем атмосферное давление в гПа PRESS = $( echo $RESPOND | sed -e 's/[{}]/''/g' | awk -v k = \"temp\" '{n=split($0,a,\",\"); for (i=1; i<n; i++) print a[i]}' | grep pressure | sed 's/:/ /g' | awk -F \" \" '{print $2}' ) # вычисляем атмосферное давление в мм рт ст из гПа MMRT = $( echo \"scale=0; ${ PRESS } *100*760/101325\" | bc ) # получаем скорость ветра WIND_SPEED = $( echo $RESPOND | sed -e 's/[{}]/''/g' | awk -v k = \"temp\" '{n=split($0,a,\",\"); for (i=1; i<n; i++) print a[i]}' | grep wind | sed 's/:/ /g' | awk '{$1=$2=\"\"; print $0}' | sed 's/ //g' ) # получаем направление ветра в градусах WIND_DEGREE = $( echo $RESPOND | sed -e 's/[{}]/''/g' | awk -v k = \"temp\" '{n=split($0,a,\",\"); for (i=1; i<n; i++) print a[i]}' | grep deg | sed 's/:/ /g' | awk -F \" \" '{print $2}' ) # округляем значения градусов до целых WIND_DEGREE = $( echo ${ WIND_DEGREE } | awk '{split($0, n, \".\"); print n[1] + (substr(n[2], 1, 1) >= 5 ? 1 : 0)}' ) WIND_DIRECTION = \"\" # эта магия по определению направления в словесной форме направления ветра if ([ $WIND_DEGREE -ge 0 ] && [ $WIND_DEGREE -lt 15 ]) || ([ $WIND_DEGREE -gt 345 ] && [ $WIND_DEGREE -lt 360 ]) ; then WIND_DIRECTION = \"north\" elif [ $WIND_DEGREE -ge 15 ] && [ $WIND_DEGREE -le 75 ] ; then WIND_DIRECTION = \"north-east\" elif [ $WIND_DEGREE -gt 75 ] && [ $WIND_DEGREE -lt 105 ] ; then WIND_DIRECTION = \"east\" elif [ $WIND_DEGREE -ge 105 ] && [ $WIND_DEGREE -le 165 ] ; then WIND_DIRECTION = \"south-east\" elif [ $WIND_DEGREE -gt 165 ] && [ $WIND_DEGREE -lt 195 ] ; then WIND_DIRECTION = \"south\" elif [ $WIND_DEGREE -ge 195 ] && [ $WIND_DEGREE -le 255 ] ; then WIND_DIRECTION = \"south-west\" elif [ $WIND_DEGREE -gt 255 ] && [ $WIND_DEGREE -lt 285 ] ; then WIND_DIRECTION = \"west\" elif [ $WIND_DEGREE -ge 285 ] && [ $WIND_DEGREE -le 345 ] ; then WIND_DIRECTION = \"north-west\" else WIND_DIRECTION = \"error\" fi # получаем сведения о влажности в % HUMIDITY = $( echo $RESPOND | sed -e 's/[{}]/''/g' | awk -v k = \"temp\" '{n=split($0,a,\",\"); for (i=1; i<n; i++) print a[i]}' | grep humidity | sed 's/:/ /g' | awk -F \" \" '{print $2}' ) # выводим всё на stdout echo \"Weather: ${ TEMPERATURE } °C | ${ INFO } \" echo \" press: ${ MMRT } mmHg, humidity: ${ HUMIDITY } %\" echo \" wind: ${ WIND_SPEED } m/s, dir: ${ WIND_DIRECTION } \" Потом в конфиге conky, на моей системе он живёт по адресу ~/.conkyrc в секцию conky.text=[[ ... ]] вот такую строку: ... ${ execi 300 /path/to/weather_parse.sh CityName,countryCode } ... Всё. Идею почерпнул отсюда","tags":"linux","title":"Костыль для погоды на conky"},{"url":"https://stonedastronaut.github.io/10-sovetov-kotorye-pomogut-vam-raskryt-svoi-potentsial-razrabotchika.html","text":"Многие рекрутеры признаются, что им тяжело найти талантливого и достаточно искусного программиста, который не боится учиться дальше и готов к любым тяготам работы. Своим опытом общения с молодыми (и не очень) специалистами поделился Аарон Стэннард, сооснователь и технический директор компании Petabridge, которая создает распространяемое ПО для .Net разработчиков. В своем блоге он определил 10 привычек, которые мешают развитию карьеры многих разработчиков. Мы внимательно изучили его статью и сформулировали несколько советов, которые помогут от этих привычек избавиться. 1. Не бойтесь изучать новые инструменты, языки и фреймворки При изучении чего-то нового вы, скорее всего, стараетесь определить все плюсы и минусы объекта исследования. Если вы стараетесь найти как можно больше минусов в новом инструменте чтобы не изучать дальше это очень опасный момент. Скорее всего, у вас уже есть несколько «универсальных» инструментов, которые вы искренне любите и применяете повсеместно. Слово «универсальные» не зря взято в кавычки, ведь на самом деле таких инструментов не существует. Не цепляйтесь за свои любимые языки и фреймворки, изучайте и используйте новые. Хороший специалист всегда знает больше одного языка, и по статистике больше зарабатывает. 2. Делайте коммиты, даже если не «допилили» Реже всего делают коммиты те разработчики, которые не умеют воспринимать критику со стороны коллег или боятся проверки начальства. Такие сотрудники тормозят работу всей группы, потому что никто не знает, как много они сделали и чем они занимаются в данный момент. Именно эти люди ответственны за задержки и баги, которые проявляются в последнюю минуту. Этот совет может показаться бесполезным многим студентам и программистам-одиночкам. Если вы редко делаете коммиты, вам тяжелее отследить и учесть все внесенные изменения, а также оценить прогресс. 3. Вы думаете, что достаточно много знаете Это касается начинающих программистов, которые не согласны с первым пунктом статьи. Скорее всего, вы постоянно учитесь, много читаете о новейших средствах разработки и используете только их. Вы легко можете рассказать, что можно сделать с помощью, например, ключевых слов async/await в C#. Но вы уверены, что понимаете, как они работают? Не стоит использовать новый инструмент только потому, что он новый. Даже если вы знаете, что он делает, постарайтесь разобраться в том, как он это делает. Если вы воспользуетесь этим советом, поведение вашего кода при отладке станет более предсказуемым, вы будете быстрее справляться с багами. 4. Хватит анализировать Умение анализировать еще никому не помешало, а вот аналитический паралич очень даже. Хватит анализировать, начинайте писать код! Аналитический паралич это бич многих разработчиков. Возможно, вы слишком много сомневаетесь потому что когда-то приняли неверное решение. Помните, что обдумывать гораздо легче, чем воплощать в жизнь. Ищите решение, пока не найдете наиболее подходящее. Не нужно бесконечно анализировать и сравнивать его с другими вариантами! Среднестатистический разработчик боится сделать ошибку, потому что не хочет выглядеть глупо. Опытного разработчика это не волнует. Он пишет какой-нибудь код, потом тестирует. И если результат его не устраивает, то удаляет все и пишет заново. Сильный разработчик понимает опасность аналитического паралича: вы как бы работаете, но на самом деле ничего не делаете. 5. Развивайте свои навыки Обычный разработчик тратит много времени на изучение возможностей того или иного API. Он вкладывает массу времени в освоение утилит или структуры 3D-графиков, но так и остается штампующим заурядные продукты, среднестатистическим программистом. Если вы хотите быть талантливым разработчиком, уделяйте больше времени совершенствованию полученных навыков и знаний. Помните, что главным фактором, отличающим начинающего разработчика от опытного, является умение быстро учиться и работать. Думаете, что писать одновременно быстро и хорошо невозможно? Научитесь работать быстро, все остальное придет с опытом. Среднестатистический программист ничего не вкладывает в свои инструменты, процесс разработки и IDE. Подумайте о том, как вы работаете. Как вы тестируете свои программы и ищете баги? Вы когда-нибудь экспериментировали с поиском решения проблемы, искали новые пути, которые могут помочь создать более удобный в сопровождении код? Когда в последний раз вы меняли IDE или текстовый редактор? Насколько автоматизирован ваш процесс разработки и тестирования? Проблема может быть не в вашем коде, а в том, как вы его пишете. 6. Не стесняйтесь просить о помощи Один мой хороший друг часто просил помощи у одногруппников. Если он не находил нужную информацию в сети, то обращался к более опытным ребятам. Конечно, над ним иногда посмеивались, только ему было все равно. Однажды этот парень показал свой код и мне. Ни один другой наш одногруппник не писал так понятно и хорошо, как он. Даже при том, что он всей душой ненавидел комментарии. Никогда не бойтесь показать свою работу другому программисту и попросить совет. Мир не рухнет, если вы скажете «я не знаю, как это сделать». Попросив о помощи вы гораздо быстрее решите проблему и научитесь писать так, чтобы вас понимали сотрудники. 7. Научитесь писать понятный код Как единственный ребенок в семье не привык делиться своими игрушками, так и вы не можете объяснить свой код другому программисту. Умение работать в команде крайне важно. Научитесь писать так, чтобы ваш код понимали не только ваши сотрудники, но и члены других команд разработчиков. Большинство разработчиков и не задумываются о том, что кто-то другой будет работать с их кодом. А между тем нечитабельный код может стать источником многих проблем. Опытные разработчики понимают свой «технический долг» и стараются писать так, чтобы их понимали коллеги. 8. Научитесь читать чужой код К счастью, вы не единственный программист на этой планете. Скорее всего, с вашей проблемой сталкивался кто-то еще, и давно нашел оптимальное решение. Это не значит, что вы всегда должны копипастить и не пытаться решать проблему самостоятельно. Опытные разработчики знают цену времени и не изобретают заново велосипеды. Они используют существующие библиотеки и инструменты, старательно их изучают и вносят поправки. Читать чужой код гораздо сложнее, чем писать собственный, но хорошие специалисты не зря вкладывают силы и время на его изучение. 9. Представьте свой продукт с точки зрения пользователя Даже если вы создаете инструменты для разработчиков, научитесь смотреть на свой продукт со стороны. Программист решает не только технические проблемы: ваша работа должна соответствовать бизнес-требованиям компании. Многие разработчики забывают об этом. Они знают, что должен делать их код и отрабатывают пару-тройку сценариев использования. Они забывают о том, что пользователь может случайно нажать не на ту кнопку или закрыть окно программы до завершения операции. Вместо отработки нескольких сценариев использования они пишут гору документации. Научитесь смотреть на свой продукт с точки зрения конечного пользователя. Как ваша программа облегчит им жизнь? Удобен ли интерфейс? Какие варианты использования могут быть? Если вы разрабатываете продукт самостоятельно, привлеките к составлению требований и тестированию друзей и знакомых. Работа пойдет гораздо быстрее, если вы точно знаете, что нужно вашим пользователям. 10. Установите денежную стоимость вашего ПО Даже технически подкованные разработчики могут не понимать ценность своего продукта, потому что не могут взглянуть на него со стороны предпринимателя или организации. Опытные разработчики умеют принимать правильные бизнес-решения и определять, на что потратить время. Они часто задают такие вопросы: Является ли этот API настолько важным, чтобы я тратил на него свое время? Сколько времени займет изучение этого фреймворка? У меня есть две недели на решение проблемы. Что я должен изучить, чтобы с легкостью решать подобные проблемы в будущем? Среднестатистический разработчик этого не делает. Он изучает спецификации и слепо им следует, даже не пытаясь понять, насколько его работа соответствует бизнес-требованиям компании и как она влияет на членов команды. ©skillkit","tags":"copy\\paste","title":"10 советов, которые помогут вам раскрыть свой потенциал разработчика"},{"url":"https://stonedastronaut.github.io/using-websockets-with-spring-angularjs-and-sockjs.html","text":"сырой перевод, неоконченная версия Некоторое время назад я написал статью о веб-приложении использующем Spring AngularJS и WebSocket'ы. Тем не менее, это руководство использует только часть того что могут WebSocket'ы, поэтому в этом руководстве я буду объяснять как Вы можете написать небольшой чат используя фреймворки Spring, AngularJS, Stromp.js и SockJS. Всё приложения будет написан с использованием JavaConfig, даже web.xml (который я до сих пор храню с прежнего руководства) будет заменён на WebAppInitializer. Приложение которое будем писать, будет выглядить вот так: Почему WebSocket'ы? Однажды, кто-то решил написать приложение почтовой рассылки. Для начала он сделал клиент который проверял наличие новых писем каждую минуту. Тем не менее, часто не было новых писем, а клиент всегда отправлял запрос, делая большую нагрузку на сервер. Эта техника была довольно популярна, и была названа polling (пер. с англ. \"опросник\"). Затем, через некоторое время, они использовали новую технику, когда клиент будет проверять, если есть новая почта, и сервер будет отвечать как только новая почта станет доступна. Эта техника была немного лучше чем поллинг, но Вы всё равно должны отправлять запрос, в результате чего использовался лишний (блоикрующий) трафик, мы назвали эту технику long-polling . Когда Вы начинаете думать, можете сделать только один вывод, это сервер должен отправить сообщение клиенту, когда новая почта станет доступна. Клиент не должен инициировать запрос, а сервер должен делать это. Это было невозможно долгое время, пока не были придуманы WebSocket'ы. WebSocket'ы это протокол и JavaScript API, протокол низкоуровневый, двунаправленный ( full-duplex ), это означает, что сообщения могут быть отправлены в обе стороны соединения одновременно. Это даёт возможность для того что бы сервер отправлял данные клиенту, но не наоборот. Polling и long-polling стали больше не нужны, и жили они долго и счастливо... Потому как WebSocket'ы предоставляют связь в друх направлениях, они часто используются для приложений реального времени. Если например, кто-то откроет Ваше приложение и изменит в нём какие-либо данные, Вы можете непосредственно обновить эти данные для всех пользователей, которые используют WebSocket'ы. Установка проекта Вам будут необходимы несколько библиотек, основная это Spring Web MVC фреймворк для настройки нашего веб-приложения и Spring messaging + WebSockets для WebSocket'ной части приложения. Нам также необходим JSON сериализатор, например Jackson, потому что Stomp нуждается в JSON сериализации/десериализации, поэтому я также собираюсь добавить его в наше приложение. pom.xml ... <dependency> <groupId> org.springframework </groupId> <artifactId> spring-webmvc </artifactId> <version> 4.1.1.RELEASE </version> </dependency> <dependency> <groupId> org.springframework </groupId> <artifactId> spring-websocket </artifactId> <version> 4.1.1.RELEASE </version> </dependency> <dependency> <groupId> org.springframework </groupId> <artifactId> spring-messaging </artifactId> <version> 4.1.1.RELEASE </version> </dependency> <dependency> <groupId> javax.websocket </groupId> <artifactId> javax.websocket-api </artifactId> <version> 1.0 </version> <scope> provided </scope> </dependency> <dependency> <groupId> javax.servlet </groupId> <artifactId> javax.servlet-api </artifactId> <version> 3.1.0 </version> <scope> provided </scope> </dependency> <dependency> <groupId> javax.servlet </groupId> <artifactId> jstl </artifactId> <version> 1.2 </version> </dependency> <dependency> <groupId> com.fasterxml.jackson.core </groupId> <artifactId> jackson-core </artifactId> <version> 2.3.3 </version> </dependency> <dependency> <groupId> com.fasterxml.jackson.core </groupId> <artifactId> jackson-databind </artifactId> <version> 2.3.3 </version> </dependency> <dependency> <groupId> com.fasterxml.jackson.jaxrs </groupId> <artifactId> jackson-jaxrs-json-provider </artifactId> <version> 2.3.3 </version> </dependency> ... На front-end я добавлю нужные билиотеки, которые настрою при помощи Bower. Если Вы им не пользуетесь, Вы всегда можете скачать эти библиотеки вручную. { \"name\" : \"spring-ng-chat\" , \"version\" : \"0.0.1-SNAPSHOT\" , \"dependencies\" : { \"sockjs\" : \"0.3.4\" , \"stomp-websocket\" : \"2.3.4\" , \"angular\" : \"1.3.8\" , \"lodash\" : \"2.4.1\" } } Библиотеки которые я собираюсь использовать SockJS + Stomp.js для связи меджу WebSocket'ами, AngularJS буду использовать для настройки клиентской части приложения и Lo-Dash библиотека утилит (форк Underscore.js). Что такое STOMP ? Как я говорил раньше, WebSocket протокол довольно низкоуровневый, однако есть неколько высоко-(выше-) уровневых протоколов, которые могут быть использованы поверх WebSocket'ов, например MQTT и STOMP . STOMP например добавляет дополнительные возможности к WebSocket'ам, такие как публикация и подписка на темы. Java конфигурация Вместо конфигурации нашего протокола используя XML, я покажу вам как вы можете написать аналогичное приложения без использования XML файлов. Первый класс который нам понадобиться который заменяет наш web.xml, для загрузки нашего веб-приложения. В данном случае мы может определить application context, web application context и некоторые другие относящиеся к сервлетам конфигурации. public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { @Override protected void customizeRegistration ( ServletRegistration . Dynamic registration ) { registration . setInitParameter ( \"dispatchOptionsRequest\" , \"true\" ); registration . setAsyncSupported ( true ); } @Override protected Class < ?>[] getRootConfigClasses () { return new Class < ?>[] { AppConfig . class , WebSocketConfig . class }; } @Override protected Class < ?>[] getServletConfigClasses () { return new Class < ?>[] { WebConfig . class }; } @Override protected String [] getServletMappings () { return new String [] { \"/\" }; } @Override protected Filter [] getServletFilters () { CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter (); characterEncodingFilter . setEncoding ( StandardCharsets . UTF_8 . name ()); return new Filter [] { characterEncodingFilter }; } } Большая часть данного класса вполне понятна. Прежде всего у нас есть getRootConfigClasses() и getServletConfigClasses() которые мы использовали для определения наших бинов. getServletMappings() и getServletFilters() связаны с конфигурацией сервлета. В данном случае я определяю приложение в context root и я добавляю фильтр для прогонки всего контента в кодировку UTF-8 . После последний метод здесь это customizeRegistrion() . Это может быть очень важно если Вы запускаете приложение на Tomcat контейнере. Здесь объясняется, что возможна ассинхронная связь, поэтому эти соединения не должны закрываться сразу. Как Вы могли заметить, Вы будете получать три ошибки при компиляции, о классах которые на найдены. Я определю их сейчас, и начнём с AppConfig : @Configuration @ComponentScan ( basePackages = \"be.g00glen00b\" , excludeFilters = { @ComponentScan.Filter ( value = Controller . class , type = FilterType . ANNOTATION ), @ComponentScan.Filter ( value = Configuration . class , type = FilterType . ANNOTATION ) }) public class AppConfig { } Пустой и бесполезный класс, кторый говорит какой пакет сканировать, но исключает все конфигурационные и контроллер классы (конфигурационные классы которые загружаются нашим WebAppInitializer когда Controller классы связанные с нашим WebConfig ). Так нам нужен будет лишь контроллер, этот класс не будет делать ничего особенного, но если вы используете специальные сервисы, тогда они станут Spring бинами, если их правильно аннотировать. Следующий класс это WebConfig : @Configuration @EnableWebMvc @ComponentScan ( basePackages = \"be.g00glen00b.controller\" ) public class WebConfig extends WebMvcConfigurerAdapter { @Bean public InternalResourceViewResolver getInternalResourceViewResolver () { InternalResourceViewResolver resolver = new InternalResourceViewResolver (); resolver . setPrefix ( \"/WEB-INF/views/\" ); resolver . setSuffix ( \".jsp\" ); return resolver ; } @Override public void configureDefaultServletHandling ( DefaultServletHandlerConfigurer configurer ) { configurer . enable (); } @Bean public WebContentInterceptor webContentInterceptor () { WebContentInterceptor interceptor = new WebContentInterceptor (); interceptor . setCacheSeconds ( 0 ); interceptor . setUseExpiresHeader ( true ); interceptor . setUseCacheControlHeader ( true ); interceptor . setUseCacheControlNoStore ( true ); return interceptor ; } @Override public void addResourceHandlers ( ResourceHandlerRegistry registry ) { registry . addResourceHandler ( \"/libs/**\" ). addResourceLocations ( \"/libs/\" ); registry . addResourceHandler ( \"/app/**\" ). addResourceLocations ( \"/app/\" ); registry . addResourceHandler ( \"/assets/**\" ). addResourceLocations ( \"/assets/\" ); } @Override public void addInterceptors ( InterceptorRegistry registry ) { registry . addInterceptor ( webContentInterceptor ()); } } Эта настроичный класс, загружающий наш веб-контекст. Он говорит нам какой статичный ресурс может быть обслужен (с addResourceHandlers . Он добавляет ~~нет кеш-перехватчик~~ ( webContentInterceptor() и addInterceptors() ) и также объяснит нам расположение наших динамических ресурсов ( JSP файлов) которые используются в getInternalResourceViewResolver() бине. И наконец WebSocket конфиг: @Configuration @EnableWebSocketMessageBroker @ComponentScan ( basePackages = \"be.g00glen00b.controller\" ) public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker ( MessageBrokerRegistry config ) { config . enableSimpleBroker ( \"/topic\" ); config . setApplicationDestinationPrefixes ( \"/app\" ); } @Override public void registerStompEndpoints ( StompEndpointRegistry registry ) { registry . addEndpoint ( \"/chat\" ). withSockJS (); } } Также как и WebSocket он сканирует компоненты в контроллер пакетах, потому что мы определим наш WebSocket траффик в наши контроллеры. Тогда мы должны сконфигурировать брокер сообщений (где связь входит и выходит) используя configMessegeBroker и мы также должны сконфигурировать наши конечные точки registerStompEndPoints . WebSocket'ы не работают во всех броузерах. Много WebSocket библиотек (например SockJS и Socket.io) предоставляют запасной вариант использования long-polling и polling . Spring также предоставляет эти запасные варианты совместимые с SockJS. Именно поэтому выбрать SockJS как клиент - это хорошая идея. Объект обмена данными Наше основное соединение будет проходить через WebSocket. Что бы общаться мы вышлем определенную \"полезную нагрузку\" и ответ, на специфический Stomp.js заголовок. Нам необходимо два класса для этого, Message и OutputMessage . Во-первых, Message будет содержать сообщение чата и сгенерированное ID, например: public class Message { private String message ; private int id ; public Message () { } public Message ( int id , String message ) { this . id = id ; this . message = message ; } public String getMessage () { return message ; } public void setMessage ( String message ) { this . message = message ; } public int getId () { return id ; } public void setId ( int id ) { this . id = id ; } } OutputMessage наследуется от Message , но также добавит временную метку (текущее время): public class OutputMessage extends Message { private Date time ; public OutputMessage ( Message original , Date time ) { super ( original . getId (), original . getMessage ()); this . time = time ; } public Date getTime () { return time ; } public void setTime ( Date time ) { this . time = time ; } } Spring Controller Заключительной java частью приложения является контроллер который отображает два случая, первый для HTML/JSP страницы содержащей наше приложение, и остальной WebSocket трафик: @Controller @RequestMapping ( \"/\" ) public class ChatController { @RequestMapping ( method = RequestMethod . GET ) public String viewApplication () { return \"index\" ; } @MessageMapping ( \"/chat\" ) @SendTo ( \"/topic/message\" ) public OutputMessage sendMessage ( Message message ) { return new OutputMessage ( message , new Date ()); } } Что здесь происходит достаточно просто, когда мы идём в context root, мы увидем этот viewApplication() отображается сюда же, поэтому эта index.jsp страница и использует эту view . Другой метод, sendMessage() предоставляет нам вещание сообщения в /topic/message когда сообщение введено в брокер сообщений /app/chat (не забудьте определить префикс /app в WebSocketConfig ). View Теперь наш внутренний java код написан, далее опишем JSP страницу. Эта страница будет содержавть 2 основных компонента: форму для отправки нового сообщения и список введенных сообщений. <!DOCTYPE HTML> <html lang= \"en\" > <head> <link href= \"http://fonts.googleapis.com/css?family=Open+Sans:400,300,600,700\" rel= \"stylesheet\" type= \"text/css\" /> <link href= \"assets/style.css\" rel= \"stylesheet\" type= \"text/css\" /> </head> <body ng-app= \"chatApp\" > <div ng-controller= \"ChatCtrl\" class= \"container\" > <form ng-submit= \"addMessage()\" name= \"messageForm\" > <input type= \"text\" placeholder= \"Compose a new message...\" ng-model= \"message\" /> <div class= \"info\" > <span class= \"count\" ng-bind= \"max - message.length\" ng-class= \"{danger: message.length > max}\" > 140 </span> <button ng-disabled= \"message.length > max || message.length === 0\" > Send </button> </div> </form> <hr /> <p ng-repeat= \"message in messages | orderBy:'time':true\" class= \"message\" > <time> {{ message.time | date :'HH:mm' }} </time> <span ng-class= \"{self: message.self}\" > {{ message.message }} </span> </p> </div> <script src= \"libs/sockjs/sockjs.min.js\" type= \"text/javascript\" ></script> <script src= \"libs/stomp-websocket/lib/stomp.min.js\" type= \"text/javascript\" ></script> <script src= \"libs/angular/angular.min.js\" ></script> <script src= \"libs/lodash/dist/lodash.min.js\" ></script> <script src= \"app/app.js\" type= \"text/javascript\" ></script> <script src= \"app/controllers.js\" type= \"text/javascript\" ></script> <script src= \"app/services.js\" type= \"text/javascript\" ></script> </body> </html> Прежде всего мы добавим Open Sans шрифт и нашу таблицу стилей (которую опишем позже в этом руководстве). Затем мы описываем тело и загрузку AngularJS прложения, которое мы назвали appChat . В этом приложении мы добавим один AngularJS контроллер - ChatCtrl . Не путайте этот с нашим Spring котроллером! В первую очередь что мы должны сделать, это создать форму содержащую текстовое поле. Мы соединим это поле с моделью названной message . Когда форма будет отправлена, addMessage() функция в нашем контроллере будет вызвана, которую мы будем использовать для отправки сообщения при помощи WebSocket'ов. Для того что бы форма была попышнее мы также добавим счетчик наподобие того который используеться в Twitter. В каждый момент времени будет отображаться сколько Вы ввели символов ( max ), при превышении лимита счетчик загораеться красным и тогда Вы больше не можете отправить форму благодаря директиве ng-disabled . Сообщения отсортированы по их дате, последнее из них показывается сверху списка. В конце страницы мы подгружаем все библиотеки которые нам нужны, и JavaScript файлы нашео приложения. Загрузка AngularJS приложения Наш первый JavaScript файл - app.js. Этот файл определяет все модули пакетов,в этом случае: angular . module ( \"chatApp\" , [ \"chatApp.controllers\" , \"chatApp.services\" ]); angular . module ( \"chatApp.controllers\" , []); angular . module ( \"chatApp.services\" , []); AngularJS контроллер AngularJS контроллер достаточно простой, как он будет пересывать всё в отдельный сервис, мы опишем далее в этом руководстве. Контроллер содержит три модели свяанные с полями, это message которое будет содержать только что введенное сообщение в textbox, messages массив который содержит все отправленные сообщения и также max - максмум допустимых символов в сообщении, используемое как Twitter счётчик символов для твита. angular . module ( \"chatApp.controllers\" ). controller ( \"ChatCtrl\" , function ( $scope , ChatService ) { $scope . messages = []; $scope . message = \"\" ; $scope . max = 140 ; $scope . addMessage = function () { ChatService . send ( $scope . message ); $scope . message = \"\" ; }; ChatService . receive (). then ( null , null , function ( message ) { $scope . messages . push ( message ); }); }); Мы уже объяснили кто когда форма отправляется, addMessage ф-я вызывается, которая будет передаст сообщение дальше сервису, и которая очистит поле сбросив модель сообщения как пустую строку. Мы также вызываем сервис для получения сообщений. Эта часть сервиса будет возвращать отложенно, кадлый ра когда сообщения получены, обновит прогресс части директивы. Контроллер будет рагировать на это сообщение добавляя его в массив messages . AngularJS служба Последняя часть нашего AngularJS клиентского приложения - это сервис. Сервис немного сложенее поскольку он будет содержать весь код обработки WebSocket трафика. Код этого сервиса: angular . module ( \"chatApp.services\" ). service ( \"ChatService\" , function ( $q , $timeout ) { var service = {}, listener = $q . defer (), socket = { client : null , stomp : null }, messageIds = []; service . RECONNECT_TIMEOUT = 30000 ; service . SOCKET_URL = \"/spring-ng-chat/chat\" ; service . CHAT_TOPIC = \"/topic/message\" ; service . CHAT_BROKER = \"/app/chat\" ; service . receive = function () { return listener . promise ; }; service . send = function ( message ) { var id = Math . floor ( Math . random () * 1000000 ); socket . stomp . send ( service . CHAT_BROKER , { priority : 9 }, JSON . stringify ({ message : message , id : id })); messageIds . push ( id ); }; var reconnect = function () { $timeout ( function () { initialize (); }, this . RECONNECT_TIMEOUT ); }; var getMessage = function ( data ) { var message = JSON . parse ( data ), out = {}; out . message = message . message ; out . time = new Date ( message . time ); if ( _ . contains ( messageIds , message . id )) { out . self = true ; messageIds = _ . remove ( messageIds , message . id ); } return out ; }; var startListener = function () { socket . stomp . subscribe ( service . CHAT_TOPIC , function ( data ) { listener . notify ( getMessage ( data . body )); }); }; var initialize = function () { socket . client = new SockJS ( service . SOCKET_URL ); socket . stomp = Stomp . over ( socket . client ); socket . stomp . connect ({}, startListener ); socket . stomp . onclose = reconnect ; }; initialize (); return service ; }); Итак начнём снизу. В самом низу кода вы можете увидеть, что мы выполняем initialize() ф-ю для настройки сервиса. Это произойдет один раз, поскольку AngularJS сервисы синглтоны, это означает что кадждый раз один и тот же экземпляр будет возвращен. Функция initialize() настроит SockJS WebSocket клиент и использует его для Stomp.js WebSocket клиента. Stomp.js является дополнением к WebSocket протоколу которое позволяет подписываться и публиковать темы и также позволяет JSON полезную нагрузку. Когда клиент присоединился к WebSocket серверу, затем вызываеться startListener() ф-я, которая будет слушать /topic/message заголовок по которому будут получены все сообщения. Он затем отправит отложенные данные, которые будут использоваться контроллерами. startListener() ф-я вызывает getMessage() функцию, которая переводит WebSocket данные (полезная нагрузка) в модель необходимую контроллеру. В этом случае парсинг JSON строки в объект, и он будет устанавливать время как Date объект. Если поядковый номер (ID) сообщения был найден в messageIds массиву, то это означает что сообщение создано в этом клиенте, поэтому свойство self будет обозначено как true . Затем она удалит этот ID сообщения из списка, потому что они доступны снова в пуле ID сообщений. Когда соединение с WebSocket'ом сервера потеряно, это вызовет ф-ю recconect() будет пытаться возобновить совединение после 30 секунд. В конце мы имеем две публичные функции нашего сервиса, receive() и send() . Начнём с receive() функции, так как она простейщая среди них. Единственное что эта функция делает, это возвращает отложено к отправке сообщения. send() функция с другой стороны отправляет сообщения как JSON объект (поле строка) и генерирует новый ID. Этот ID добавляеться к messageIds массиву, так что он может быть использован функцией getMessage() для проверки было ли добавлено сообщение данным клиентом, или другим. Стилизация Это весь Java и JavaScript код который необходим, теперь закончим наше приложение добавив в него крутых стилей. Я использую следующий CSS код: body , * { font-family : 'Open Sans' , sans-serif ; box - sizing : border - box ; } .container { max-width : 1000px ; margin : 0 auto ; width : 80% ; } input [ type = text ] { width : 100% ; border : solid 1px #D4D4D1 ; transition : .7s ; font-size : 1.1em ; padding : 0.3em ; margin : 0.2em 0 ; } input [ type = text ] :focus { - webkit - box - shadow : 0 0 5px 0 rgba ( 69 , 155 , 231 , . 75 ); - moz - box - shadow : 0 0 5px 0 rgba ( 69 , 155 , 231 , . 75 ); box - shadow : 0 0 5px 0 rgba ( 69 , 155 , 231 , . 75 ); border-color : #459be7 ; outline : none ; } .info { float : right ; } form :after { display : block ; content : '' ; clear : both ; } button { background : #459be7 ; color : #FFF ; font-weight : 600 ; padding : .3em 1.9em ; border : none ; font-size : 1.2em ; margin : 0 ; text-shadow : 0 0 5px rgba ( 0 , 0 , 0 , . 3 ); cursor : pointer ; transition : .7s ; } button :focus { outline : none ; } button :hover { background : #1c82dd ; } button :disabled { background-color : #90BFE8 ; cursor : not - allowed ; } .count { font-weight : 300 ; font-size : 1.35em ; color : #CCC ; transition : .7s ; } .count.danger { color : #a94442 ; font-weight : 600 ; } .message time { width : 80px ; color : #999 ; display : block ; float : left ; } .message { margin : 0 ; } .message .self { font-weight : 600 ; } .message span { width : calc ( 100% - 80px ); display : block ; float : left ; padding-left : 20px ; border-left : solid 1px #F1F1F1 ; padding-bottom : .5em ; } hr { display : block ; height : 1px ; border : 0 ; border-top : solid 1px #F1F1F1 ; margin : 1em 0 ; padding : 0 ; } Демонстрация Перед тем как запустить наше приложение на веб сервере, сперва проверим некоторые вещи. Во-первых, убедимся, что вы настроили ваш context root на /spring-ng-chat/ . Если вы этого не сделаеле, Ваш AngularJS сервис будет иметь проблемы с соединением к WebSocket серверу, так как он связан с /spring-ng-chat/chat . Если вы не хотите это, вы можете всегда изменить свойство SOCKET_URL в AngularJS сервисе. Во-вторых, если вы запустите это приложение из встроенного в Eclipse Tomcat'а, вам прйдеться добавить ваши Maven зависимости в ваш deployment сборку. Вы можете сделать это в настройках проекта, выбрав Deployment assembly и добавив эти библиотеки. В конце концов убедитесь что контейнер который вы используете, поддерживает WebSocket Java API. Если это не так, то вам скорее всегда необходимо обновить ваш веб контейнер. Если всё это готово, то можете начать запуск вашего приложения, которое выглядит вот так: Если вы начнёте набирать ваше сообщение, вы увидете что кнопка теперь активировалась, и счётчик запустился. Если вы будете набирать дальше, то увидите, что кнопка деактивировалась снова, и счётчик теперь показывается отрицательное значение в красном цвете: Как только Вы введёте сообщение и отправите его, Вы увидите что оно появится в списке сообщений, жирным шрифтом (потому как оно Вы его отправили). Вы также увидите, что поле ввода сообщения было очищено: Если вы откроете приложение в новом окне, вы сможете увидеть что оно пустое. Так как WebSocket'ы работают в режиме реального времени, поэтому только сообщения которые были доставлены в положенное время будут видны в списке сообщений, здесь нет истории сообщений. Если Вы отправили сообщение в другом окне, вы должны будете увидеть это сообщение на обоих окнах. Но только на одном будет выделено жирным текстом, а на другом обычным. Как Вы можете видеть, WebSocket'ы работают должным образом и вы увидете сообщения появляются в режиме реального времени, потому что клиент отправляет сообщение на сервер, который отправляет это сообщение всем клиентам. Такая сервер-клиентная модель возможно только благодаря WebSocket'ам. source","tags":"java","title":"Использование WebSocket'ов совместно со Spring, AgularJS и SocksJS"},{"url":"https://stonedastronaut.github.io/hotkey-dlia-brouzera-v-kde.html","text":"/bin/bash -c \"`xdg-settings get default-web-broswer | sed 's/.desktop//g'`\"","tags":"linux","title":"Hotkey для броузера в Kde"},{"url":"https://stonedastronaut.github.io/dekoratory-v-python.html","text":"Никакой волшебно новой информации здесь не будет, скорее это самому себе объяснение, что за зверь такой декораторы в python. Т.к. в pyhton ф-ии являются объектами, то к ним можно применить шаблон проектирования декоратор . Сам шаблон я на момент написания этих строк не разбирал, посему тут может быть не совсем корректная информация о том насколько правильно реализуется данный шаблон в случае ф-ий языка python. Итак. Декоратор - это возможность расширения ф-нала имеющейся ф-ии(объекта). Получается что-то типа наследования, но без создания новой сущности. Для реализации декораторов необходимо написать сам декоратор, это ф-ия которая принимает в качестве параметра другую ф-ю(именно её адрес, а не её вызов) и оборачивает её како-либо логикой. Например: def decorator ( some_func ): def wrapper (): # делаем что-то перед вызовом оборачиваемой ф-ии print ( \"before\" ) # вызываем оборачиваемую ф-ю some_func () # делаем что-то после вызова обернутой ф-ии print ( \"after\" ) return wrapper def just_func (): print ( \"Я не изменюсь, но меня можно обернуть\" ) теперь обернем just_func decorator ( just_func )() # before # Я не изменюсь, но меня можно обернуть # after Можно подобному вызову ф-ии присовить имя: just_func_wrapped = decorator ( just_func ) И при вызове just_func_wrapped получим тоже самое: just_func_wrapped () # before # Я не изменюсь, но меня можно обернуть # after Мы почти добрались до сути. Собственно как это можно было записать при помощи синтаксиса декораторов: @decorator def just_func (): print ( \"Я обернутая ф-я\" ) И вызвав just_func получим: just_func () # before # Я обернутая ф-я # after Т.е. синтаксис декоторов это синтаксический сахар заменяющий такую конструкцию: def just_func (): pass just_func = decorator ( just_func ) # равносильно такой записи @decorator def just_func (): pass Передача аргументов внутрь обертки Также можно, а точнее это и нужно, передавать агрументы внутрь ф-ии декоратора, оборачиваемой ф-ии. def decorator ( just_func ): def wrapper ( arg1 , arg2 ): print ( \"before\" ) print ( \"Я получил внутрь аргументы \" + arg1 + \" \" + arg2 ) # вызываем ф-ию с аргументами just_func ( arg1 , arg2 ) print ( \"after\" ) return wrapper @decorator def just_func ( str1 , str2 ): print ( str1 + \" \" + str2 ) just_func ( \"Привет\" , \"Мир\" ) # before # Я получил внутрь аргументы Привет Мир # Привет Мир # after Декор методов в классах Всё то же самое за исключением, что метод отличается от ф-ии тем, что первым аргументом метода, всегда является ссылка на свой класс. def decorator ( class_method ): def wrapper ( self , some ): print ( \"Это обёртка для метода класса\" ) print ( 1000 + some ) return class_method ( self , some ) return wrapper class MyClass ( object ): def __init__ ( self ): self . var = 2 @decorator def my_method ( self , some ): print ( self . var + some ) m = MyClass () m . my_method ( 1 ) # 1003 # Хотя по-идее мы могли бы ожидать 1 + 2, но благодаря обертке мы смогли # изменить функционал Передача *args и **kwargs декорируемой ф-ии Ничего волшебного: def decorator ( just_func ): def wrapper ( * args , ** kwargs ): return just_func ( * args , ** kwargs ) return wrapper @decorator def just_func ( * args , ** kwargs ): print ( args ) print ( kwargs ) just_func () # () # {} Передача аргументов декоратору Логично возникает вопрос: \"А как же передать аргументы в декоратор, если декоратор по определению должен принимать на вход только имя декорируемой ф-ии?\". Решение есть, но не лёгкое. Задекорируем декоратор (crazy). # ф-ия создающая декоратор def decorator_for_decorator (): # ф-я декоратор (т.е. изменяющая ф-ал оборачиваемой ф-ии) def decorator ( func ): # ф-ия обертка def wrapper (): # some logic func () return wrapper return decorator new_decorator = decorator_for_decorator () # создаем декоратор и присваиваем его переменной def just_func (): print ( \"Я просто ф-я\" ) # задекорируем ф-ю just_func = new_decorator ( just_func ) # и теперь можем вызвать задекорированную ф-ю just_func () Или можно записать так: def just_func (): print ( \"я декорируемая ф-я\" ) just_func = decorator ()( just_func ) # и вызов задекорированной ф-ии just_func () А теперь то же самое, но только при помощи @ : @decorator_for_decorator () def just_func (): print ( \"я декорируемая ф-я\" ) just_func () Т.к. декоратор теперь есть вызов ф-ии, то можем передать ему некие аргументы: def deco_for_deco ( deco_arg1 , deco_arg2 ): print ( deco_arg1 + deco_arg2 ) def decorator ( just_func ): def wrapper ( func_arg1 , func_arg2 ): # данная обертка теперь имеет доступ как к аргументам # декоратора, так и к аргументам декорируемой ф-ии return just_func ( func_arg1 , func_arg2 ) return wrapper return decorator @deco_for_deco ( \"Привет\" , \"Мир\" ) def just_func ( arg1 , arg2 ): print ( \"Меня задекорировали, и знаю только\" + \\ \"о своих аргументах %s и %s \" % ( arg1 , arg2 )) # выведет: \"ПриветМир\" just_func ( \"один\" , \"два\" ) # выведет: Меня задекорировали, и знаю только о своих аргументах один и два Зная всё что здесь написано можно сделать декоратор для декораторов которому можно передавать любые аргументы: def deco_for_deco ( decorataion_decorator ): def decorator_maker ( * args , ** kwargs ): def decorator_wrapper ( func ): return decoration_decorator ( func , * args , ** kwargs ) return decorator_wrapper return decorator_maker Теперь посмотрим как воспользоваться этой адовой смесью: @deco_for_deco def decorated_decorator ( func , * args , ** kwargs ): def wrapper ( func_arg1 , func_arg2 ): print ( \"Я знаю о %s и %s \" % ( args , kwargs )) return func ( func_arg1 , func_arg2 ) return wrapper Теперь декорируем нужные нам ф-ии передавая любые аргументы декоратору: @decorated_decorator ( 42 , 404 , 1024 ) def just_func ( arg1 , arg2 ): print ( \"Привет\" + arg1 + arg2 ) just_func ( \" Жвачка и \" , \"Мир\" ) # выведет: # Я знаю о (42, 404, 1024) и {} # Привет Жвачка и Мир Подводя итоги В общем этот длиннопост переработанный изхабра, создавался когда я врубался в подсмотренный код в django, где в 4 строках скрыто целая тьма смысла и материала для изучения. Там создавался класс mixin в котором декорировался некий метод который обезапасивал доступ к сайту. Ацкая смесь без развернутых пояснений на англ. языке. Ну вот собственно с декораторами вроде разобрался. Где еще применяется декорирование? Декораторы могут быть использованы для расширения возможностей функций из сторонних библиотек (код которых мы не можем изменять), или для упрощения отладки (мы не хотим изменять код, который ещё не устоялся). Так же полезно использовать декораторы для расширения различных функций одним и тем же кодом, без повторного его переписывания каждый раз, например: def benchmark ( func ): \"\"\" Декоратор, выводящий время, которое заняло выполнение декорируемой функции. \"\"\" import time def wrapper ( * args , ** kwargs ): t = time . clock () res = func ( * args , ** kwargs ) print func . __name__ , time . clock () - t return res return wrapper def logging ( func ): \"\"\" Декоратор, логирующий работу кода. (хорошо, он просто выводит вызовы, но тут могло быть и логирование!) \"\"\" def wrapper ( * args , ** kwargs ): res = func ( * args , ** kwargs ) print func . __name__ , args , kwargs return res return wrapper def counter ( func ): \"\"\" Декоратор, считающий и выводящий количество вызовов декорируемой функции. \"\"\" def wrapper ( * args , ** kwargs ): wrapper . count += 1 res = func ( * args , ** kwargs ) print \"{0} была вызвана: {1}x\" . format ( func . __name__ , wrapper . count ) return res wrapper . count = 0 return wrapper @benchmark @logging @counter def reverse_string ( string ): return str ( reversed ( string )) print reverse_string ( \"А роза упала на лапу Азора\" ) print reverse_string ( \"A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!\" ) # выведет: # reverse_string ('А роза упала на лапу Азора',) {} # wrapper 0.0 # reverse_string была вызвана: 1x # арозА упал ан алапу азор А # reverse_string ('A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!',) {} # wrapper 0.0 # reverse_string была вызвана: 2x # !amanaP :lanac a ,noep a ,stah eros ,raj a ,hsac ,oloR a ,tur a ,mapS ,snip ,eperc a ,)lemac a ro( niaga gab ananab a ,gat a ,nat a ,gab ananab a ,gag a ,inoracam ,elacrep ,epins ,spam ,arutaroloc a ,shajar ,soreh ,atsap ,eonac a ,nalp a ,nam A Скопипащенно © отсюда","tags":"python","title":"Декораторы в Python"},{"url":"https://stonedastronaut.github.io/perevod-stati-pola-grekhema-o-prichudakh-programmistov.html","text":"По просьбам трудящихся — перевод статьи Пола Грехема (Paul Graham) ‘Holding a Programm in One's Head'. Хороший программист, работающий над собственным проектом, может удерживать его целиком в голове так, как удерживает математик уравнение, которое решает. Математики не решают задачи на листке бумаги, так, как этому учат детей в школе. Вместо этого большинство операций они производят в уме, создавая некий образ в голове, примерно как мы можем мысленно представить образ дома, в котором провели детство. С программированием все точно так же. Вы можете создать некий образ всего текущего проекта в голове и рассмотреть его тщательно со всех сторон. Это чаще всего бывает востребовано на начальном этапе, когда одной из важнейших вещей является возможность поменять то, что ты делаешь. Не просто решить задачу другим способом, а поменять саму ее суть. Но уместить целую программу в голове не так то просто. Если по какой-либо причине вы не обращались к коду несколько месяцев, может потребоваться до нескольких дней, чтобы опять в него вникнуть. Даже когда вы активно работаете над программой, для настройки собственного сознания на работу над текущей задачей может потребоваться до получаса каждое утро. И это лишь в лучшем случае. Типичные программисты, работающие в офисных условиях, не могут справиться с этим и до самого окончания рабочего дня. Говоря другим языком, типичный офисный программист никогда не понимает целиком задачи, которую ему приходится решать. Даже лучшие программисты порою не имеют цельного представления программы в своей голове. Если вам кажется, что последнее относится и к вам, то ниже предлагаются способы решения этой проблемы: Как можно меньше отвлекайтесь. Отвлечение внимания может сыграть плохую роль в работе людей множества профессий, но особенно это явно для программистов, которые часто работают с количеством деталей, которые приходится помнить, превышающим все мыслимые и немыслимые пределы. Последствия от переключения внимания на постороннюю задачу зависят не столько от его продолжительности, сколько от степени отвлечения внимания этой задачей. Так, например, программист может выйти из офиса, перекусить бутербродом сидя на лавочке, ни на минуту не отвлекаясь в это время от программы, над которой работает. Особенно вредными могут быть незапланнированные ситуации, которые отнимают гораздо больше внимания, чем запланированные, перед которыми программист обычно и не начинает никаких серьезных задач. Работайте запоем. Т.к. каждый раз перед началом работы необходимо втянуться в текущую задачу, очевидным решением по минимизации ненужных затрат является долгая работа без значительных перерывов. Разумеется, бесконечно работать невозможно, и в один момент вы поймете, что окнчательно «отупели» от работы. Быстрота наступления такого состояния зависит исключительно от особенностей конкретного человека. Я слышал о людях, которые работали по 36 часов подряд, дни напролет. Мой максимум это 18 часов, но наиболее комфортно я себя чувствую при работе не более 12 часов подряд. Оптимальный вариант это не тот, который максимально допускают ваши физические и, пожалуй, психические способности. Иногда, когда вы делаете перерыв в работе, а затем возвращаетесь, к вам приходят неожиданные решения, выработанные вашим мозгом пока ваши мысли, казалось бы, были далеки от программного кода. Пишите на лаконичных языках. Мощные языки программирования делают ваши программы короче. Программисты думают о программах, по крайней мере частично, на том языке, на котором их пишут. Чем лаконичней язык, тем короче программа, и тем легче восстановить в своей памяти ее образ. Вы можете достигнуть еще большего эффекта используя восходящий стиль программирования, когда вы пишете программы состоящие из абстрактных слоев, нижние из которых создают базу и программную оболочку для верхних. Если вы будете делать это правильно, вам достаточно будет хранить в своей памяти лишь самый верхний слой. Постоянно переписывайте программы. Переписывая код, вы зачастую улучшаете архитектуру приложения. Даже если и нет, в этом есть преимущество: чтобы переписать программу заново, необходимо полностью понимать ее суть. Так вы сможете воссоздать более точную картину программы у себя в голове. Пишите код, который удобно читать вам. Все программисты знают как хорошо писать код, который будет легко читать. Но вы сами являетесь наиболее важным читателем своего кода. Особенно в начале проекта; создание прототипа будущего приложения это ваш диалог с самим собой. Когда вы пишете сами для себя, перед вами стоят совершенно иные приоритеты. Когда вы пишете для других, ваш код может размазываться на множество строк для лучшей читабельности. Когда же вы пишете код для того, чтобы его можно было легко восстановить в памяти, вы скорее предпочтете краткость. Работайте маленькими группами. Когда вы представляете программу в своем воображении, вы уделяете основное внимание собственноручно написанному коду, части же, написанные другими людьми, вы понимаете не настолько хорошо и не можете так живо представить их. Таким образом, чем меньше программистов работают над проектом, тем целостнее вы способны представить его образ. Если вы работаете над ним в одиночку, вы способны на все. Не допускайте редактирование одного и того же кода несколькими людьми. Как я уже сказал, вы никогда не сможете понять чужой код так же хорошо как собственный. Не имеет значения как тщательно вы его прочитали, вы всего лишь прочитали его — не написали. Таким обазом, если участок кода написан несколькими людьми, то ни один из них не имеет полного и цельного его представления. И безусловно, вы не сможете что-то кардинально поменять в нем. Не потому что вам нужно для этого разрешение, а потому что вы просто не можете представить себе этого. Реорганизация кода, написанного несколькими людьми это как реорганизация законов мироздания. Реорганизация собственного кода, это просто другая интерпретация неоднозначного образа программы, находящегося в вашей голове. Если вам необходимо несколько людей для разработки одного проекта, разделите его на части и выделите по одной каждому программисту. Начинайте с малого. Чем более досконально вы изучаете программу, тем легче вам создать ее мысленный образ. Вы можете представлять отдельные части готовой программы как черные коробки выполняющие свои функции не вдаваясь в детали реализации до тех пор, пока не будете к этому готовы. Когда же вы начинаете новый проект, вам просто необходимо удерживать его в голове полностью. Если вы начнете со слишком сложной и объемной задачи, вы, вероятно, никогда не сможете охватить ее целиком. Если перед вами стоит подобная задача, начните не с ее формального описания, а с написания прототипа, который решает одну из ее подзадач. Каковы бы ни были преимущества планирования, они зачастую не так значительны по сравнению с преимуществами, которые вы получаете от возможности держать весь проект у себя в голове. Удивительно как часто программисты придерживаются всех восьми пунктов даже не подозревая об их существовании. Когда у кого-то появляется идея, ему приходится заниматься ею вне рабочего времени, так как она не имеет официальной поддержки руководства. Это приводит к более продуктивной работе в виду отсутствия отвлекающих факторов. Ведомый вперед чистым энтузиазмом программист работает ночи напролет. Т.к. его проект носит исключительно экпериментальный характер, он пишет код не на языках, являющихя корпоративным стандартом, а на лаконичных скриптовых языках. Он полностью переписывает программу заново, что не получило бы одобрения вышестоящих людей, будь это официальной разработкой. Но в данном случае это личный проект, и он хочет сделать его идеально. Учитывая, что никто кроме него не увидит код, он пишет его как можно более сжато и кратко, так, чтобы было легче взяться за него после перерыва. Проектом занято лишь небольшое кол-во людей, даже если он пишет его и не один, т.к. изменения кода происходят так быстро, что нет возможности подключать к проекту кого-то еще. И наконец, он начинает с малого, потому что его задумка изначально действительно была небольшой и скромной. Еще более удивительным является число официальных проектов, которые каким-то образом умудряются нарушать все восемь «правил». И в самом деле, если вы взглянете на методы разработки программного обеспечения в большинстве организаций, то увидите что они как будто бы нарочно делают все неправильно. В некотором роде так и есть. Одной из отличительных черт организаций является восприятие людей как взаимозаменяемых частей общего механизма. Это работает хорошо для задач, допускающих распараллеливание задач между участниками, таких, например, как война. Во всей истории нет ни одного упоминания случая, когда хорошо организованная армия натренированных наемников уступала бы армии, состоящей из самостоятельных воинов, насколько бы доблесными они ни были. Но мыслительный процесс не очень то можно распределить между людьми. А что такое программирование, если не мыслительный процесс. Не совсем верно утверждение, что организации отрицают возможность быть зависимыми от одного гениального сотрудника. Просто в нашем сегодняшнем понимании, организации по определению должны не допускать этого. Возможно, нам стоит дать определение новому типу организаций, которые бы использовали совместную деятельность отдельных сотрудников без необходимости для них быть взаимозаменяемыми. В некоторой степени рынок можно назвать подобного рода организацией, хотя более удачным описанием было бы описание рынка как вырожденного случая, того, что получается само собой, когда организация неуместна. Может быть нам стоит выбрать некий обходной путь и сделать так, чтобы программисты работали отлично от других сотрудников. Вероятно для больших компаний оптимальным решением будет не производить идеи самостоятельно, а закупать их у других. Несмотря на то, какое из решений будет уместно в каждом конкретном случае, необходимо сначала осознать существование проблемы. В самой фразе «компания разработки ПО» заключено противоречие. Слова как будто отталкиваются друг от друга в противоположных направлениях. Любой хороший программист будет чувствовать себя в чужой тарелке, находясь в большой организации, т.к. организации придуманы такими, чтобы недопускать того, чего программист больше всего жаждет. Хороший программист так или иначе справляется со множеством задач. Однако во многих случаях для этого ему приходится чуть ли не организовывать восстание против собственной компании. Такое поведение обусловлено самими требованиями к его работе. Программисты с головой уходят в программирование, забывая о других своих обязанностях, бросаются писать код, не описав его спецфикаций, переписывают уже работающий код не потому что безответственны. Они предпочитают работать в одиночку и гневаются на здоровающиеся головы коллег, периодически показывающиеся из дверного проема, не потому что не дружелюбны или замкнуты. Этот кажущийся совершенно случайным набор привычек в их поведении имеет единственную причину: необходимость держать в своей голове весь проект целиком. Поможет или нет понимание этого большим компаниям, оно безусловно может помочь их конкурентам. Наиболее слабое место таких компаний в том, что они не позволяют программистам выполнять значимую работу. Если вы маленькая начинающая компания, то воспользовавшись этим вы можете составить им значительную конкуренцию. Просто учитывайте особенности задачи, которую мозг программиста должен брать на себя целиком. ©megamozg","tags":"copy\\paste","title":"Перевод статьи Пола Грэхема о «причудах» программистов"},{"url":"https://stonedastronaut.github.io/raznitsa-mezhdu-kliuchevymi-slovami-this-i-super-v-java.html","text":"this и super — это два специальных ключевых слова в Java, которые представляют соответственно текущий экземпляр класса и его суперкласса. Java-программисты часто путают эти слова и обнаруживают слабую осведомленность об их специальных свойствах, о которых нередко спрашивают на интервью по Java Сore. Вот, например, пара вопросов, из того, что сразу приходит на ум, о this и super , Можно ли присвоить другое значение ключевому слову this в Java? и какая разница между ключевыми словами this и super в Java. Не знаете? Ну что ж, здесь я ответа не даю — его можно найти в конце статьи. Так вот, как я уже сказал в начале, главное отличие между this и super в Java в том, что this представляет текущий экземпляр класса, в то время как super — текущий экземпляр родительского класса. Вот один из примеров использования переменных this и super — вы наверняка уже видели примеры вызовов конструкторов одного из другого, т.н. вызовы конструкторов по цепочке, это возможно благодаря использованию ключевых слов this и super . Внутри класса для вызова своего конструктора без аргументов используется this() , тогда как super() используется для вызова конструктора без аргументов, или как его ещё называют, конструктора по умолчанию родительского класса. Между прочим, таким способом вызывать можно не только конструктор без аргументов, а и вообще любой другой конструктор, передав ему соответствующие параметры. Скоро мы увидим пример такого использования this и super . Ещё this и super в Java используются для обращения к переменным экземпляра класса и его родителя. Вообще-то, к ним можно обращаться и без префиксов super и this , но только если в текущем блоке такие переменные не перекрываются другими переменными, т.е. если в нем нет локальных переменных с такими же именами, в противном же случае использовать имена с префиксами придется обязательно, но это не беда, т.к. в таком виде они даже более читабельны. Классическим примером такого подхода является использование this внутри конструктора, который принимает параметр с таким же именем, как и у переменной экземпляра. Дальше в статье мы узнаем, какие ещё есть отличия между super и this , и рассмотрим некоторые примеры их использования. Чем this и super похожи Прежде чем рассматривать отличия ключевых слов this и super , давайте посмотрим на некоторые их сходства: И this , и super — это нестатические переменные, соответственно их нельзя использовать в статическом контексте, а это означает, что их нельзя использовать в методе main. Это приведет к ошибке во время компиляции «на нестатическую переменную this нельзя ссылаться из статического контекста». То же самое произойдет, если в методе main воспользоваться ключевым словом super . И this , и super могут использоваться внутри конструкторов для вызова других конструкторов по цепочке, нпр., this() и super() вызывают конструктор без аргументов наследующего и родительского классов соответственно. В примере ниже мы сначала передаем вызов из конструктора без аргументов класса B в конструктор этого же класса B, принимающий один параметр типа String, из которого, в свою очередь, с помощью super(\"\") вызывается конструктор с одним аргументом из суперкласса. :::java class A{ A(){ System.out.println(\"Конструктор без аргументов класса A\"); } A(String args){ System.out.println(\"Конструктор с одним аргументом класса A\"); } } class B extends A{ B(){ this(\"\"); // вызов конструктора с одним аргументом класса B System.out.println(\"Конструктор без аргументов класса B\"); } B(String args){ super(\"\"); // вызов конструктора с одним аргументом класса A System.out.println(\"Конструктор с одним аргументом класса B\"); } } // Тест-класс и вывод public class Test { public static void main(String args[]) { B b = new B(); } } Вывод: Конструктор с одним аргументом класса A Конструктор с одним аргументом класса B Конструктор без аргументов класса B Внутри конструктора this и super должны стоять выше всех других выражений, в самом начале, иначе компилятор выдаст сообщение об ошибке. Из чего следует, что в одном конструкторе не может быть одновременно и this() , и super() . Различия в super и this Теперь мы знаем как использовать ключевые слова super и this и понимаем для чего они нужны. Но есть ещё один вариант использования этих ключевых слов, о котором я не сказал — во Внутренних классах, где с их помощью очень удобно ссылаться на внешний класс, используя форму записи Outer. this для его текущего экземпляра и Outer. super — для его родителя. Не забудьте вместо Outer подставить имя внешнего класса. А теперь давайте кратко перечислим главные отличия между ключевыми словами this и super 1) переменная this ссылается на текущий экземпляр класса, в котором она используется, тогда как super — на текущий экземпляр родительского класса. 2) Каждый конструктор при отсутствии явных вызовов других конструкторов неявно вызывает с помощью super() конструктор без аргументов родительского класса, при этом у вас всегда остается возможность явно вызвать любой другой конструктор с помощью либо this() , либо super() . Пожалуй, это все, что можно сказать о различиях между ключевыми словами this и super в Java и о том, как они используются в программах. Как мы увидели, основное их назначение — вызывать один конструктор из другого и ссылаться на переменные экземпляра, объявленные в текущем классе и его родительском классе. Не забывайте, что это не совсем обычные переменные, а сейчас — ответ на мой вопрос, который я задавал в первом параграфе. Нет, переменной this нельзя присвоить новое значение, потому что она объявлена как final. Можете попробовать сделать это в IDE — получите ошибку компиляции «нельзя присвоить новое значение переменной this — она объявлена как final». ©JavaRush","tags":"java","title":"Разница между ключевыми словами this и super в Java"},{"url":"https://stonedastronaut.github.io/neochevidnyi-sposob-borby-s-prokrastinatsiei.html","text":"Наверняка, многие слышали о таком понятии, как \"состояние потока\". Сейчас выходит много умных книжек и статей на эту тему. Но если не вдаваться в подробности и говорить простыми словами, то это такое состояние, в котором лучше всего работать. Концентрация и вовлеченность в таком состоянии максимальны, правильные решения приходят в голову быстро и естественно, ничто окружающее не отвлекает: ни захламленный рабочий стол, ни неудобное кресло, ни поздний час или голодный желудок. Все это здорово, и каждый из нас, скорее всего, вспомнит что-то из своего опыта. Но проблема в том, что \"перестроить\" себя в такое состояние не просто, а вот \"вывалиться\" из него очень легко. Особенно, если речь идет о скучной или непонятной работе, в этом случае «инерция для входа\" особенно высока. Размышляя недавно обо всем этом, я понял, что периодически неосознанно использовал один прием, которым и хочу поделиться. Итак, представим, что у нас есть некая задача, которую надо сделать как можно быстрее, и пускай она не очень нас вдохновляет, чтобы сразу с энтузиазмом на нее бросаться. Почему? Может быть, это слишком масштабная проблема, к которой непонятно с какой стороны подступиться. Или может быть, это \"наследство\", перешедшее к нам от предыдущих разработчиков, и при виде которого, наш внутренний перфекционист плачет кровавыми слезами, но на переписывание с нуля, времени в плане не предусмотрено. Или же, наконец, это может быть просто скучное задание. Чтобы сделать хоть что-то, человек должен себя замотивировать. И чаще всего, наш разум для этого использует два классических способа: \"метод кнута\" и \" метод пряника\". Метод кнута основывается на страхе. Если не сделаю работу – получу нагоняй от начальника/заказчика, не получу зарплату, не расплачусь за ипотеку, окажусь на улице, нечего будет есть и т.д. Короче, будет все очень плохо. Метод пряника, напротив, больше напоминает морковку перед осликом. Сделаю хорошо работу – оценит начальник, получу повышение и премию, получу внеочередной отгул, буду отдыхать и развлекаться, и все будет классно. И эти способы отлично работают в случае, когда \"мотиваторы\" находятся в непосредственной близости. Т.е. понимание того, что дедлайн для важнейшего проекта прошел месяц назад, а банк, выдавший вам кредит, каждые полчаса названивает с угрозами, думаю, сильно ускорит вашу работоспособность и эффективность. Аналогично, на работоспособность повлияет и уверенность в том, что результаты вашей работы над этой конкретной задачей непосредственно повлияют на трудоустройство в Google. Но, как только, мотиваторы скрываются из прямой видимости (есть еще время), любая потеря концентрации ведет к прокрастинации, или, проще говоря, к отвлечению от неприятной работы в просмотре новостей, серфинге по социальным сетям или раскладывании солитера. Могу сказать из своего опыта, что особенно это сильно проявляется в случае, когда работа ведется из дома. Есть ли какие-то альтернативные способы войти в \"состояние потока\"? На мой взгляд, один из таких обходных путей, это начать работу с интересной мелочи. Из всего объема проекта, несмотря на приоритеты и запланированные этапы разработки, выбирается какая-то интересная мелочь. Для программиста, это может быть какая-то незначительная, но прикольная \"фишка\", для дизайнера – второстепенная и неважная иконка. Конечно, можно сказать, что на какую-то неважную фигню будет потрачено пару часов времени, которые лучше было бы потратить на действительно важные и приоритетные задачи. Но главное здесь в том, что в процессе работы над этими мелочами, мы входим в рабочее состояние, разгоняемся до необходимого состояния. И первоначальный интерес здесь выступает в роли некого ускорителя и защиты от прокрастинации (силы трения). Главное, не забыть потом переключиться на нужные задачи, чтобы не начать клепать еще десять \"фишек\" и новую сотню иконок. ©geektimes","tags":"copy\\paste","title":"Неочевидный способ борьбы с прокрастинацией"},{"url":"https://stonedastronaut.github.io/kak-v-20-let-ia-stal-zarabatyvat-po-2-3k-evro-v-mesiats-na-google-adsense-i-chem-eto-zakonchilos.html","text":"Моя история может быть полезна всем, кто уже начинает зарабатывать на своем веб-сайте или только хочет попробовать. Меня зовут Александр. Я родился в Казахстане в 1992 году. В 12 лет я потерял отца и переехал в Приднестровье, а затем и в Румынию, когда мне было 16 лет. В данный момент заканчиваю в Румынии университет. В будущем планирую двинуть в Лондон и окончить магистратуру по e-commerce. Семейная трагедия придала огромный импульс в том, чтобы учиться делать деньги разными способами, от купли и продажи металлолома в поселке городского типа до заработка на веб-сайте в интернете. В данной публикации я затрону 3 самые важные темы, которые отражают мой опыт: I. Веб-сайт: — Деньги на создание сайта; — Какую платформу и хостинг выбрал для веб-сайта; — С какими проблемами сталкивался. II. Продвижение через Фэйсбук и подписчиков: — Как за полтора года я сделал 250 тыс. подписчиков, которые приносили мне большой (для румынского медиа) трафик; — Стратегии использования Фэйсбук-страниц как источника дохода для веб-сайта. III. Монетизация через Google Adsense: — Как начать; — Пару лайфхаков, как поднять количество кликов по рекламе; — Как не переборщить. Предупреждаю, излагать буду в хронологическом порядке, вы поймете связь, а важные советы буду помечать вот так: *** Как все начиналось В 2011 году (я тогда заканчивал среднюю школу) сделал фан-страницу на Facebook {Nu ai sa crezi}, где постил разную интересную информацию с книг и рунета (в переводе на румынский язык), а так же большое количество фотографий по теме (вы можете увидеть их по этой ссылке). Получал много замечаний. Ну, что там замечания… меня покрывали 10-ти этажным матом за орфографические и лексические ошибки, так как тогда не очень хорошо румынским языком. Тем самым пользователи своими высказываниями помогали мне изучать еще лучше румынский язык. Помню, за месяц я набрал 10 тысяч пользователей на фан-странице, а дальше процесс сам запустился… Люди «комментили» и «лайкали» мои посты, тем самым увеличивая охват и популярность страницы. Внимание, ответ на вопрос, как я сделал первые 10 тыс лайков: *** У моих знакомых на «Фэйсбуке» большое количество людей в друзьях. У кого 500 друзей, у кого 3 тысячи, у кого по 100-200; я не выпускал никого из виду. На каждой вечеринке, а их было много, перед тем, как перейти к вину или пиву, я вежливо (при необходимости добавляя долю ироничной жалости или грубости) просил сделать друзей администраторами страницы, это позволяло мне приглашать всех их друзей ставить лайки, отмечая мою страницу как понравившуюся. Данный способ и сейчас эффективен, к вашему счастью «Фэйсбук» сделал эту опцию видимой для всех пользователей страницы (те, кто «лайкнул» ее), и нет никакой необходимости назначать вашего друга админом, чтобы отправить приглашение. Расширяйте как можно больше свою армию друзей и знакомых и помогайте друг другу. Как я создавал веб-сайт Далее передо мной возник вопрос, как сделать сайт и монетизировать его… Нужны были деньги для хостинга и веб-сайта. В тот период я начал торговать недорогой фэшн-бижутерией на центральной улице возле антикварной лавки, рядом с мной стояли хэнд-мэйд умельцы, которые продавали свои собственные изделия, и все мы вместе платили арендую плату за место. Но почему-то умельцы смотрели косо в мою сторону, так как девушки-студентки наседали на мою бижутерию (которую я покупал килограммами и продавал поштучно ) как пчелы на мед. Никогда не любил зависть. Так за сезон я сделал достаточную сумму денег, чтобы оплатить первый год в университете, купить ноутбук, а остальное инвестировать в создание веб-сайта и его продвижение. Первое, что я сделал, это зарегистрировал доменное имя и купил простой хостинг у американцев, который обошелся мне в триста с лишним долларов в год. Здесь я совершил ошибку, купив всяких тупых функций, которые вообще НЕ НУЖНЫ, так как в этом ничего не понимал тогда. Хватило мне его на 3 месяца, дальше возник вопрос, что делать, чтобы сервер не падал от большого количества трафика. Если на сайт заходило 100 чел, он падал. Значит, отказался я от их услуг и по совету службы поддержки купил VPS-cервер в Канаде — уже за 450 долларов в год, но который держал 1 000-3 000 пользователей на сайте одновременно. Для сайта я использовал Wordpress — cамую популярную платформу среди блогеров и даже серьезных новостных сайтов. . Потом я купил тему Wordpress и установил ее… И снова ошибка! Ошибка состояла в том, что я не обращал внимания на корректность кода или оптимизацию, так как не разбирался в этом. Так что перед покупкой советуйтесь с программистами или с теми, кто в курсе. Когда сайт был готов, страница на Фэйсбуке уже имела 30 тыс лайкнувших ее пользователей. Были времена, когда мои посты на сайте доходили до 100 тыс, что приносило мне большое количество трафика. Вывод: не жалуйтесь, что у вас нет лишних денег на создание профессионального блога, зарабатывайте любыми способами (желательно, легальными). Один в поле не воин, или как я создал мини-редакцию Я не справляся с переводами и всем остальным. Пришлось брать талантливых знакомых в команду, 2 переводчика и редактор, плюс отдельно работал программист. Тогда мы переводили все самые крутые статьи с Рунета и адаптировали их под румынскую публику. На сайт приходило много трафика, во всяком случае, для румынского медиа. Руководить всем этим процессом… одно это уже вам понравится! Да и работать с командой — это большой дар. Cайт стал популярным, так как большинство медиа писали полную ерунду. А я, можно сказать, изменил румынское медиа, благодаря своей двуязычной мультикультуре, и большинство блогеров начали копировать или использовать «наш» стиль контента. Со временем я понял, что людям нравится больше всего, и какой тип статей вызывает у них эмоции, которыми они готовы делиться, принося, таким образом, все больше и больше трафика. Я работал на трафик и качество. Как я продвигал сайт через Facebook, или Facebook — золотой ресурс трафика для сайта Очень важно найти другие страницы на Facebook и совершать взаимообмен. Так, я сотрудничал с 4 страницами на «Фейсбуке». Мы каждый раз обменивались материалами, фотографиями, тем самым обоюдно обеспечивая рост страниц + трафик на сайт (бесплатно). Платите за рекламу и продвижение в том случае, если доходы от нее хотя бы покрывают ваши расходы. Общайтесь со своими поклонниками как с друзьями, не называйте их фанами. Стройте добрые отношения с каждым, кто дал лайк, делитесь с ними своим опытом. Знаю, это тяжело и убивает много времени. Но результаты стоят того. Нужно создать армию, которая будет следовать за вами, и которая будет приносить победы в разных формах: больше трафика, больше прибыли и т.д. Это я осознал очень поздно, к сожалению. Титул и фотки:http://vk.cc/3B6H7y Очень большую роль играют название статьи и фотография, от этого зависит конверсия «Фэйсбук»-трафика. Это два Туза в кармане! Очень важно, чтобы и то, и другое вызывало эмоцию, cтрасть. На сайте, где кнопка лайк (и другие копки, типа share), придумайте прикольную фразу, чтобы люди делились постами, ни в коем случае не унижайтесь. Отвечайте на зло добром. Ни с кем не ругайтесь. Добавьте все возможные маты в черный список. ** Не забудьте про разнообразие постов на сайте: одно фото-много текста, много фото-мало текста, видео+текст, тесты, флэш-игры и т.д. Тестируйте материалы на разную тематику, сделайте анализ и узнайте, что приносит больше трафика на сайт. Дальше вы уже поймете, что приносит вам трафик, а что нет. Теперь, главный пункт повествования: Google Adsense как один из лучших способов монетизации веб-сайта Моя единственная возможность монетизировать сайт (в моем случае, румынское медиа) — Google Adsense, т.к. Affiliate (партнерские программы) плохо работали на сайте. Впрочем, с партнеров я тоже выжимал по 30-200 евро в месяц. Моя первая прибыль в Google Adsense составила 70 евро за месяц, деньги приходили через Western Union. Пожалуй, ничто не мотивирует делать больше денег, как желание заработать еще больше. С каждым месяцем я зарабатывал все больше и больше:http://vk.cc/3B6HO Для этого мне нужно было поднимать процент кликов по рекламе и трафик на сайт, в основном через FB. Изначально мой CTR варьировался в диапазоне от 0,40% до 0,80%. Все, кто пользуется Google Adsense, пытаются найти статьи про то, как поднимать СTR в этой рекламной сети (если на сайт зашло 100 человек, и один из них сделал клик по рекламе, то CTR=1%). Вперед к новым победам На деньги, которые сделал на Adsense, купил себе машину и инвестировал в разработку 2 новых веб-сайтов (магазин и, конечно, самое важное для меня – онлайн-журнал, где все лояльные читатели будут оформлять годовую или месячную подписку). Скоро планирую запуск. От нечего делать я создал проект, монетизация которого базируется на affiliate программах и на консультациях. Трафик пока маловат — 60-70 человек в день, но он уже растет с каждым днем. При достижении органического трафика в 100 человек в день мы планируем установить чат и давать бесплатные советы начинающим блогерам. Мой контракт с Google Adsense для меня закончился плачевно. Причиной этому стал большой уровень CTR для сайта с моей тематикой. Но вышел я из этого стресса с высоко поднятой головой, которую в нелегкие моменты осенили новые проекты, 2 из них будут готовы к этому лету. Как я уже упомянул, это онлайн-магазин, а так же новый блог, из которого я хочу сделать молодой платный журнал для «умных». Так же в планах запустить cеть cайтов под affiliate программы. Но самое главное — это терпение. То, что тебя не убивает, делает сильнее. Недавно мне попалась на глаза умная фраза. Я согласен с ней на 100%: «удивительно, люди говорят, что три года на создание своего бизнеса – это долго, а ходить на работу сорок лет – это нормально». Cтатья заканчивается, но не заканчивается сама тема, я готов развивать ее и передавать свой опыт, отвечая на ваши вопросы в комментариях к этой публикации. Бонус первым пятерым, кто пользуется Google Adsense, оставляйте в комментариях адрес вашего сайта, после того, как я его проанализирую, помогу дельными советами. Жду ваших вопросов, буду рад помочь поделиться своим опытом. Итак, у вас есть два варианта на выбор: Первый: «вы видите, что все реально, работайте и удача вам улыбнется! Встретимся на Багамах.» Второй: «вы видите, как все сложно, дурак не пробьется никогда, поэтому ищите что-нибудь по проще. Да, я и сам бросаю заниматься этой фигней и иду работать официантом.» Лично я бы остановился на первом варианте, а вообще, пусть каждый сам для себя решит, где он хочет провести остаток дней — на Гоа или в городе Тайшет. Все в ваших руках, ногах, голове и сердце. ©megamozg","tags":"copy\\paste","title":"Как в 20 лет я стал зарабатывать по 2-3K евро в месяц на Google Adsense, и чем это закончилось"},{"url":"https://stonedastronaut.github.io/10-zapovedei-bezlichnogo-programmirovaniia.html","text":"Эти заповеди были описаны в книге «Психология компьютерного программирования», написанной в 1971 году. Несмотря на возраст, слова до сих пор актуальны. Я не читал саму книгу, но нашёл пост о ней в блоге Стивена Уайетта Буша. Стивену её посоветовал перед смертью его отец. Вот эти заповеди: Пойми и свыкнись с тем, что ты будешь совершать ошибки. Суть в том, что их нужно находить до того, как они на что-то повлияют. В нашей индустрии, к счастью, ошибки редко могут привести к фатальным результатам (это не относится к тем, кто работает над ПО управления ракетами в Лаборатории реактивного движения). Мы можем (и должны) учиться, смеяться над собой и двигаться дальше. Твой код — это не ты. Весь смысл проверок — в поиске недочётов. И когда их найдут, не принимай это близко к сердцу. Не важно, сколько хитрых приёмчиков ты знаешь, — всегда найдётся кто-нибудь круче тебя. И, если ты попросишь, этот человек может научить тебя парочке новых трюков. Слушай других, даже если тебе кажется, что это не нужно. Не переписывай код без обсуждения. Между исправлением кода и его переписыванием лежит тонкая грань. Пойми разницу, не меняй всё самостоятельно, добивайся изменений в рамках анализа кода. Относись к тем, кто знает меньше тебя, с уважением, терпением и пониманием. Почти все люди из нетехнического круга, которые постоянно взаимодействуют с разработчиками, считают нас, в лучшем случаем, самодовольными типами. В худшем — плаксами. Не укрепляй этот стереотип своей злостью и нетерпеливостью. Всё течёт, всё меняется. Будь открытым для изменений, принимай их с улыбкой. Воспринимай каждое изменение в требованиях, смену платформы или инструмента не как существенное неудобство, с которым нужно бороться, а как новое испытание. Настоящая власть исходит не из званий, а из знаний. Знания порождают власть, а власть порождает уважение — так что, если вы хотите уважения в безличном окружении, развивайте свои знания. Борись за то, во что веришь, но достойно принимай поражение. Пойми, иногда твои идеалы могут быть отвергнуты. Даже если ты прав, не пытайся отомстить и не говори «Я вас предупреждал». Не делай уже мёртвую идею своим лозунгом. Не будь «программистом в каморке». Не будь человеком, который выходит из своего тёмного офиса только за газировкой. Такой программист вне зоны видимости, взаимоотношений и контроля. Такой человек не имеет голоса в открытом окружении. Принимай участие в разговорах, участвуй в жизни своего офиса. Критикуй код, а не человека, — будь добр к программисту, но не к коду. Пусть все твои комментарии будут положительными и направленными на улучшение кода. Указывай в комментариях на местные стандарты, спецификации, улучшение производительности и т. д. ©habrahabr","tags":"copy\\paste","title":"10 заповедей безличного программирования"},{"url":"https://stonedastronaut.github.io/java-sobesedovanie-kollektsii.html","text":"Чем отличается ArrayList от LinkedList? В моем рейтинге это один из двух самых популярных вопросов о коллекции, задают в 90% случаев. Вызвал у меня проблему на моем первом собеседовании на Junior Developer`а. Вкратце ответ на этот вопрос сводится к следующему: ArrayList это список, реализованный на основе массива, а LinkedList — это классический связный список, основанный на объектах с ссылками между ними. Преимущества ArrayList: в возможности доступа к произвольному элементу по индексу за постоянное время (так как это массив), минимум накладных расходов при хранении такого списка, вставка в конец списка в среднем производится так же за постоянное время. В среднем потому, что массив имеет определенный начальный размер n (в коде это параметр capacity), по умолчанию n = 10, при записи n+1 элемента, будет создан новый массив размером (n * 3) / 2 + 1, в него будут помещены все элементы из старого массива + новый, добавляемый элемент. В итоге получаем, что при добавлении элемента при необходимости расширения массива, время добавления будет значительно больше, нежели при записи элемента в готовую пустую ячейку. Тем не менее, в среднем время вставки элемента в конец списка является постоянным. Удаление последнего элемента происходит за константное время. Недостатки ArrayList проявляются при вставке/удалении элемента в середине списка — это взывает перезапись всех элементов размещенных «правее» в списке на одну позицию влево, кроме того, при удалении элементов размер массива не уменьшается, до явного вызова метода trimToSize(). LinkedList наоборот, за постоянное время может выполнять вставку/удаление элементов в списке (именно вставку и удаление, поиск позиции вставки и удаления сюда не входит). Доступ к произвольному элементу осуществляется за линейное время (но доступ к первому и последнему элементу списка всегда осуществляется за константное время — ссылки постоянно хранятся на первый и последний, так что добавление элемента в конец списка вовсе не значит, что придется перебирать весь список в поисках последнего элемента). В целом же, LinkedList в абсолютных величинах проигрывает ArrayList и по потребляемой памяти и по скорости выполнения операций. LinkedList предпочтительно применять, когда происходит активная работа (вставка/удаление) с серединой списка или в случаях, когда необходимо гарантированное время добавления элемента в список. Что вы обычно используете (ArrayList или LinkedList)? Почему? Это вопрос является слегка замаскированной версией предыдущего, так как ответ на этот вопрос приведет к постепенному изложению ответа на предыдущей вопрос. В 90% случае ArrayList будет быстрее и экономичнее LinkedList, так что обычно используют ArrayList, но тем не менее всегда есть 10% случаев для LinkedList. Я говорю, что обычно ArrayList использую, ссылаясь на тесты и последний абзац из предыдущего вопроса, но не забываю и про LinkedList (в каких случаях? так же последний абзац предыдущего вопроса помогает). Что быстрее работает ArrayList или LinkedList? Еще одна замаскированная версия первого вопроса. Хитрее приведенных выше вариантов, что постановка вопроса подразумевает односложный ответ с выбором одного из предложенных вариантов, что, по задумке автора вопроса, как я понимаю, должно сразу выявить человека с неглубокими познаниями в collections. Правильным же действием будет встречный вопрос о том, какие действия будут выполняться над структурой. В итоге, диалог плавно переходит к ответу на первый вопрос. Необходимо добавить 1млн. элемент, какую структуру вы используете? Тоже довольно популярная скрытая версия первого вопроса. Так же постановка предполагает выбор одного из предложенных вариантов, хотя на самом деле информации для однозначного выбора нет. Нужно задавать дополнительные вопросы: в какую часть списка происходит добавление элементов? есть ли информация о том, что потом будет происходить с элементами списка? какие то ограничения по памяти или скорости выполнения? В целом, все тот же первый вопрос, но немного с другой стороны: вы через дополнительные вопросы, показываете глубину понимания работы Array и Linked List. Однажды я сам «клюнул» на этот крючок, домыслив про себя, что добавить — это «вставить» в конец списка и усиленно продвигал ArrayList, хотя ничего не знал (и не пытался узнать) про дальнейшие действие с этим списком и возможные ограничения. Как происходит удаление элементов из ArrayList? Как меняется в этом случае размер ArrayList? При удалении произвольного элемента из списка, все элементы находящиеся «правее» смещаются на одну ячейку влево и реальный размер массива (его емкость, capacity) не изменяется никак. Механизм автоматического «расширения» массива существует, а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой trimToSize(). Предложите эффективный алгоритм удаления нескольких рядом стоящих элементов из середины списка, реализуемого ArrayList. Допустим нужно удалить n элементов с позиции m в списке. Вместо выполнения удаления одного элемента n раз (каждый раз смещая на 1 позицию элементы, стоящие «правее» в списке), нужно выполнить смещение всех элементов, стоящих «правее» n+m позиции на n элементов левее к началу списка. Таким образом, вместо выполнения n итераций перемещения элементов списка, все выполняется за 1 проход. Как устроена HashMap? Вкратце, HashMap состоит из «корзин» (bucket`ов). С технической точки зрения «корзины» — это элементы массива, которые хранят ссылки на списки элементов. При добавлении новой пары ключ-значение, вычисляет хеш-код ключа, на основании которого вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент. Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден элемент с таким же ключом, то он заменяется. Добавление, поиск и удаление элементов выполняется за константное время. Вроде все здорово, с одной оговоркой, хеш-функций должна равномерно распределять элементы по корзинам, в этом случае временная сложность для этих 3 операций будет не ниже lg N, а в среднем случае как раз константное время. Какое начальное количество корзин в HashMap? Ответ здесь — 16. Отвечая, стоит заметить, что можно используя конструкторы с параметрами: через параметр capacity задавать свое начальное количество корзин. Какая оценка временной сложности выборки элемента из HashMap? Гарантирует ли HashMap указанную сложность выборки элемента? Ответ на первую часть вопроса, можно найти в ответе на вопрос 7 — константное время необходимо для выборки элемента. Вот на второй части вопроса, я недавно растерялся. И устройство HashMap знал и про хеш-функцию тоже знал, а вот к такому вопросу не был готов, в уме кинулся вообще в другом направлении и сосредоточился на строении HashMap откинув проблему хеш-кода, который в голове всегда привык считать хеш-кодом с равномерным распределением. На самом деле ответ довольно простой и следует из ответа вопроса 7. Если вы возьмете хеш-функцию, которая постоянно будет возвращать одно и то же значение, то HashMap превратится в связный список, с отвратной производительностью. Затем даже, если вы будете использовать хеш-функцию с равномерным распределением, в предельном случае гарантироваться будет только временная сложность lg N. Так что, ответ на вторую часть вопроса — нет, не гарантируется. Роль equals и hashCode в HashMap? Ответ на этот вопрос следует из ответа на вопрос 7, хотя явно там и не прописан. hashCode позволяет определить корзину для поиска элемента, а equals используется для сравнения ключей элементов в списке внутри корзины и искомого ключа. Максимальное число значений hashCode()? Здесь все довольно просто, достаточно вспомнить сигнатуру метода: int hashCode(). То есть число значений равно диапазону типа int — 2&#94;32 (точного диапазона никогда не спрашивали, хватало такого ответа). Как и когда происходит увеличение количества корзин в HashMap? Вот это довольно тонкий вопрос. Как показал мой мини-опрос, если суть устройства HashMap себе представляют многие более-менее ясно, то этот вопрос часто ставил собеседника в тупик. Помимо capacity в HashMap есть еще параметр loadFactor, на основании которого, вычисляется предельное количество занятых корзин (capacity*loadFactor). По умолчанию loadFactor = 0,75. По достижению предельного значения, число корзин увеличивается в 2 раза. Для всех хранимых элементов вычисляется новое «местоположение» с учетом нового числа корзин. В каком случае может быть потерян элемент в HashMap? Этот интересный вопрос мне прислал LeoCcoder, у меня подобного не спрашивали и честно признаюсь, после прочтения сходу не смог придумать сценарий для потери элемента. Все опять же оказалось довольно просто, хоть и не так явно: допустим в качестве ключа используется не примитив, а объект с несколькими полями. После добавления элемента в HashMap у объекта, который выступает в качестве ключа, изменяют одно поле, которое участвует в вычислении хеш-кода. В результате при попытке найти данный элемент по исходному ключу, будет происходить обращение к правильной корзине, а вот equals (ведь equals и hashCode должны работать с одним и тем же набором полей) уже не найдет указанный ключ в списке элементов. Тем не менее, даже если equals реализован таким образом, что изменение данного поля объекта не влияет на результат, то после увеличения размера корзин и пересчета хеш-кодов элементов, указанный элемент, с измененным значением поля, с большой долей вероятности попадет совсем в другую корзину и тогда он уже совсем потеряется. В чем отличия TreeSet и HashSet? Начнем с того, что Set — это множество (так же называют «набором»). Set не допускает хранение двух одинаковых элементов. Формально говоря, термин «множество» и так обозначает совокупность различных элементов, очень важно, что именно различных элементов, так как это главное свойство Set. С учетом такого определения, пояснение про хранение одинаковых элементом не требуется, но в обиходе, понятие «множество» потеряло свой строгий смысл касательно уникальности элементов, входящих в него, поэтому все же уточняйте отдельно данное свойство множества. TreeSet обеспечивает упорядоченно хранение элементов в виде красно-черного дерева. Сложность выполнения основных операций в TreeSet lg N. HashSet использует для хранения элементов такой же подход, что и HashMap, за тем отличием, что в HashSet в качестве ключа выступает сам элемент, кроме того HashSet (как и HashMap) не поддерживает упорядоченное хранение элементов и обеспечивает временную сложность выполнения операций аналогично HashMap. Устройство TreeSet? Здесь достаточно краткого ответа, что TreeSet основан на красно-черном дереве. Как правило этого хватает и собеседник сразу переходит к следующему вопросу, у меня ни разу не спрашивали механизм балансировки дерева или другие подробности его реализации. Что будет, если добавлять элементы в TreeSet по возрастанию? Обычно данный вопрос собеседник предваряет фразой, что в основе TreeSet лежит бинарное дерево и если добавлять элементы по возрастанию, то как они будут распределены по дереву. Если нет точного представления об устройстве TreeSet, а есть общее понимание о том, что это бинарное дерево (в чем нас дополнительно уверяет собеседник), то данный вопрос может привести к интересному результату: все элементы после доабвления в обычное бинарное дерево будут находится в одной ветви длиной N элементов, что сводит на нет, все преимущества такой структуры, как дерево (фактически получается список). На самом, деле, как выше упоминалось в основе TreeSet лежит красно-черное дерево, которое умеет само себя балансировать. В итоге, TreeSet все равно в каком порядке вы добавляете в него элементы, преимущества этой структуры данных будут сохраняться. ©habrahabr","tags":"java","title":"Java собеседование. Коллекции"},{"url":"https://stonedastronaut.github.io/razrabotka-brauzernoi-strategii.html","text":"Хочу поделиться своим опытом написания многопользовательской браузерной стратегии с нуля до рабочего проекта. С точки зрения непосредственно программирования, архитектуры и возникших проблем. Это мой первый опыт создания игры. Но не суть важно — главное я довел дело до рабочего проекта и наверняка многим будет интересно узнать подробности. Что представляет собой игра? Видимо наиболее коротким описанием будет «клон Цивилизации» =). Но это не значит что у меня не хватило фантазии придумать что-то свое. Просто сделать «Цивилизацию» было моей мечтой. Вряд ли бы я получил столько удовлетворения от написания другой игры. Ну а фанаты Цивилизации наоборот считают, что моя игра совсем не похожа на Цивилизацию, разве что только с виду. Может это и к лучшему. Игра называется The Fate of Nation Расписывать архитектуру и логику работы приложения можно до бесконечности поэтому придется видимо разделить на несколько частей статью, если к ней будет интерес. Кроме того не вижу большого смысла приводить много кода, так как реализовать написанное мной можно на любом языке и платформе. Для создания игры я использовал php и MySQL на сервере, html и javascript на клиенте. Flash не используется. Из html5 есть только видео на сайте и несколько областей с канвасом в самой игре — включая поверхность карты и мини-карту. Объем кода клиентской части в несколько раз превышает серверную часть, поэтому в основном буду рассказывать о клиентской разработке, но начнем с сервера. Общая архитектура Общая архитектура приложения выглядит как полностью асинхронное веб приложение на JavaScript. Перезагрузок страниц не предусмотрено. Обмен данными с сервером исключительно через Ajax и JSON. В JSON'е передаются только данные, без html кода. Html разметка загружается отдельно в начале загрузки приложения и процессится с данными через клиентский шаблонизатор по мере загрузки данных с сервера. image На сервере никаких фреймворков не использовал — хотя начинал писать с использованием Zend Framework, который выкосил потом за ненадобностью. Вместо него создал свою простую архитектуру отдаленно напоминающую контроллеры и экшены из ZendFramework. Как видно из рисунка, на сервере одна точка входа — файл index.php. В процессе игры на сервер идут запросы вроде такого: /Unit/Move. И посылается JSON с параметрами, в данном случае это id юнита и координаты перемещения. Сервер перенаправляет этот запрос на index.php, в котором последовательно выполняется подключение к БД, проверка текущего пользователя и парсинг строки запроса для определения контроллера (Unit) и действия (Move). Если контроллер не задан то сервер выдает индексную страницу с кодом для построения клиентского приложения, но об этом позже. Если же контроллер задан то ищется файл этого контроллера, подключается его код и запускается обработка запросов этого контроллера, где соответственно ищется необходимый экшн, а в нем производится проверка входных данных и дергается бизнес логика. image Для работы с БД написан специальный класс абстракции базы данных через который проходят все запросы к БД от бизнес логики и контроллеров, экранирование данных и прочие небольшие удобства. Собственно на сервере все довольно просто с архитектурой, а зона ответственности сервера заключается лишь в проверке входных данных и выдаче информации из БД. Все остальное делает клиент. Теперь немного о самой игре. Карта Первое что было сделано это карта на которой происходят почти все игровые действия: строительство городов, улучшений (посевы, дороги), перемещение юнитов и исследование карты. Размер карты составил 1000 на 1000 клеток для каждой отдельная запись в БД. Я видел игры где карта сделана бесконечной и записи о клетках динамически вставлялись тогда, когда с клеткой производились какие-либо действия. Но меня такой подход немного пугал своей непредсказуемостью. Гораздо проще планировать игру, когда точно знаешь, что у тебя есть фиксированная карта. Можно запланировать расположение игроков их количество, количество городов и юнитов, приблизительно оценить нагрузку. Итого получилось 1000 * 1000 = 1 000 000 записей в БД для карты. До этого я не работал с таким количеством записей и меня это насторожило. Думал что будет тормозить. image Я решил перехитрить MySql и разместить карту в 10-ти таблицах по 100 000 записей в каждой с надеждой, что станет быстрее работать. В итоге пришлось написать дурацкую логику по выборке клеток из нескольких таблиц сразу, а замеры показали что производительность только упала. Вернул все назад в 1-у таблицу. image x, y — это координаты клетки. terrain — тип территории (луг, лес, гора...). resource — ресурс если он есть на клетке (глина, лошади). wens9_code — название поля произошло от west-east-north… 9 — означает что изображение данной клетки зависит от территорий 8-ми рядом стоящих клеток и естественно от территории самой этой клетки — всего 9. Эту логику я спер с 3-ей цивилизации, насмотревшись их спрайтов территорий там где по 512 вариантов иконок для одной клетки!)) Потом у меня вскипел мозг разбирая зависимости по которым они выбирали иконки и я понял, какой это большой геморрой. =) И все только для одного: чтобы спрайты имели жесткие концы в виде ромбиков 128 на 64 пикселя. В конце концов мы решили использовать png24 с полупрозрачными краями накладывающиеся друг на друга и создающих в 10 раз лучший и разнообразный ландшафт, чем в описанном примере из Цив3. А выбираем иконки случайно независимо от соседних клеток. Это видно на скрине — сразу не скажешь где там одинаковые иконки полей. Вот горы по краям размыть забыли и они имеют четкие границы — что плохо смотрится. starting_position — означает что в этой клетке появится игрок. Конечно это не весь список полей, но здесь и далее для упрощения буду приводить только те поля, о которых рассказываю в статье. Регионы Клиент написан таким образом, что он не запрашивает с сервера определенные клетки, а запрашивает их партиями по 100 штук (10 на 10), которые я назвал регионами. То есть каждая клетка принадлежит какому-то региону и клиент запрашивает регионы и не конкретные клетки. Как только игрок перемещает карту так, что становится виден новый регион, мы посылаем запрос на сервер за этим регионом и граничащими с ним. Данные каждого загруженного регионакешируются на 30 секунд на клиенте. Это позволяет легко прокручивать карту без тормозов и лишних запросов на сервер и избавляет от задержки при появлении нового региона на карте — так как мы загружаем все соседние наперед. Когда я делал эти «регионы» я не предполагал насколько они увеличат производительность. Оказалось выделить 100 клеток фильтруя по полю региона получается многократно быстрее чем фильтруя по координатам. Несмотря на то, что я объединил x и y координаты клетки в одно поле location = 1000*x + y. Сделал это прежде всего для удобства — чтобы легче было достать одну клетку. image Затем каждую сущность (города, юниты, ресурсы), которые располагаются на карте и имеют соответственно конкретные координаты, я также пометил регионом, что увеличило производительность выборок в сотни раз. Одно дело искать значения в таблице по ключу с миллионом уникальных значений и другое дело по ключу с 10 000 значений. Таким образом получилась такая система: клиент запрашивает регионы — сервер достает из БД карту и все сущности на ней, быстро фильтруя по регионам — клиент отрисовывает это все в браузере на канвасе. У каждой сущности есть такие поля как время до окончания битвы или время до перемещения в следующую клетку — в этом случае по истечении этих таймаутов мы обновляем локально только то что требуется. Например если мы исследуем карту то догружаем только что открытые клетки и не более. Если вражеский юнит переместился — догружаем следующую точку его перемещения. Исследование карты Однако меня терзал еще один вопрос. Мне позарез хотелось сделать исследование карты — чтобы изначально она была не разведана и нужно было ходить по ней чтобы что-то увидеть. image Такого я не видел еще в браузерных играх (собственно как и юнитов передвигающихся по карте, а не по воздуху). Я принялся за расчеты. Стартовая позиция игрока расположена внутри региона. То есть максимальное количество игроков 10 000 как и регионов. Каждый игрок может разведать всю карту. Итого 10 000 * 1 000 000 = 10 миллиардов записей может быть в таблице пермишенов на клетки! Таблица карты показалась на фоне этого детским лепетом =). Конечно эта цифра завышена. Вряд ли кому-то удастся разведать всю карту — она очень большая. Но десятки и сотни миллионов записей в таблице пермишенов точно могут быть в конце игры. И на эту таблицу нужно было джойнить все сущности включая саму карту каждый раз при выборке регионов. Здесь опять спас меня ключ по полю региона, который позволил делать эти джоины намного быстрее. image Провести нагрузочное тестирование чтобы определить на каком этапе сервер начнет тормозить не удалось еще. Максимум что я видел это чуть более 2-ух миллионов записей в таблице пермишенов. Перемещение юнитов Чтобы сделать перемещение юнитов пришлось тоже подумать и переписать логику несколько раз. Первое что нам нужно, это точно отслеживать время открытия новых клеток чтобы можно было отфильтровывать клетки, юниты и города по этим данным. Сразу напрашивается использовать таблицу пермишенов на карту, но со спец-полем — означающим время когда эта запись станет активной. Так и было сделано. Клиент отправляет id юнита, и новую координату дислокации. Сервер просчитывает текущую позицию юнита, координаты клеток по которым он будет перемещаться, и в зависимости от территории этих клеток, типа юнита и других параметров высчитывает время когда этот юнит будет в каждой клетке. Затем дополнительно просчитываются таким же образом соседние клетки в зависимости от радиуса обзора юнита. Все это вставляется в таблицу пермишенов на клетки и карта работает как часы. Юнит ходит по карте, при каждом его перемещении мы запрашиваем клетки вокруг него, стандартными методами, которые отфильтруют сущности уже по новым данным пермишенов учитывая время активации пермишена, где будут заветные открытые области. Далее записи пермишенов, которые говорят о перемещении юнита мы помечаем еще 2 полями: id юнита и типом записи: 'обзорные клетки' или 'клетки по которым идет юнит'. Первое поле нужно чтобы при остановке юнита или смене пункта назначения можно было их удалить, второе нужно чтобы при выборке юнита записать ему времена смены дислокации. image Затем коллеги по работе мне подсказали еще один довольно очевидный момент: ввести поле означающее время выхода юнита с данной клетки. Я назвал его out_timestamp. Это позволило легко выбирать текущие позиции всех юнитов и соответственно фильтровать вражеских юнитов по видимым нами клеткам. Уверен, что мой пример не самая удачная архитектура для подобной игры, но вроде работает =) В следующих статьях могу рассказать о клиентской архитектуре, кешировании, используемом фреймворке и о том, как мне удалось сделать демонстрационную версию игры работающую без запросов к серверу, чисто на клиенте. Да, кстати, часто после различных постов об игре народ начинает хвалить графику, а не геймплей. Так что скажу сразу — я ее не рисовал!!! Это все наш художник-дизайнер Максим Кудрицкий. ©habrahabr","tags":"copy\\paste","title":"Разработка браузерной стратегии"},{"url":"https://stonedastronaut.github.io/emacs-navigation-options-en.html","text":"If you don't have an emacs editor, install emacs editor as we discussed earlier. Notation used in this article: C-a : Ctrl-a M-a : Meta-a ( If you don't have Meta key, use Esc key ) C-M-a : Ctrl-Meta-a 1. Emacs Line Navigation Following four navigation can be done line by line. C-p : go to previous line C-n : go to next line C-f : go forward one character C-b : go backward one character Repeat factor By using the repeat factor in EMACS we can do this operation for N times. For example, when you want to go down by 10 lines, then type C-u 10 C-p Within a line if you want to navigate to different position, you have following two options. C-a : go to the starting of the current line. C-e : go to the end of the current line. At thegeekstuff, we love Vim editor. We've written lot of articles on Vim editor. If you are new to the Vim editor, refer to our Vim editor navigation fundamentals article. 2. Emacs Screen Navigation Following three navigation can be done in relation to text shown in the screen. C-v : Jump forward one full screen. M-v : Jump backwards one full screen. ( If you dont have Meta key, use ESC key ) C-l : Make the current line as center line of window. You can also use Page Up, Page Down for screen navigation. 3. Emacs Special Navigation Following are couple of special navigation that are used to go to the start or end of buffer. M-< : Go to the start of file M-> : Go to the end of file 4. Emacs Word Navigation Following are two word navigation keys. M-f : navigate a word forward. M-b : navigate a word backward. 5. Emacs Paragraph Navigation M-a : Go to the beginning of the current paragraph. By pressing M-a again and again move to the previous paragraph beginnings. M-e : Go to the end of the current paragraph. By pressing M-e again and again move to the next paragraph end, and again. 6. Emacs Search Navigation When you want to search by giving the plain text, C-s : Type Ctrl+s followed by the word to Search. Press Ctrl+s continuously to move to the next occurrences. Press enter to terminate search. C-r : Do a reverse search. All other explanation are like Ctrl+s When you want to search using regular expression, C-M-s : Type Ctrl+s followed by the regex to Search. Press Ctrl+s continuously to move to the next occurrences. Press enter to terminate search. C-M-r : Do a reverse search. All other explanation are like Ctrl+Meta+s 7. Emacs Navigation from Command Line Emacs +N filename: Go to the Nth line of the file after opening it. $ emacs +10 /etc/passwd","tags":"copy\\paste","title":"Emacs navigation options"},{"url":"https://stonedastronaut.github.io/mysql-shpargalki.html","text":"Часто, когда разрабатываешь сайт, замечаешь, как на одни и те же грабли наступают разработчики при проектировании базы данных. Сегодня я решил опубликовать свои шпаргалки, на самые часто встречающиеся ошибки при работе с MySQL. Работа с бекапами Делаем бекап mysqldump -u USER -pPASSWORD DATABASE > /path/to/file/dump.sql Создаём структуру базы без данных mysqldump —no-data - u USER -pPASSWORD DATABASE > /path/to/file/schema.sql Если нужно сделать дамп только одной или нескольких таблиц mysqldump -u USER -pPASSWORD DATABASE TABLE1 TABLE2 TABLE3 > /path/to/file/dump_table.sql Создаём бекап и сразу его архивируем mysqldump -u USER -pPASSWORD DATABASE | gzip > /path/to/outputfile.sql.gz Создание бекапа с указанием его даты mysqldump -u USER -pPASSWORD DATABASE | gzip > date +/path/to/outputfile.sql.%Y%m%d.%H%M%S.gz Заливаем бекап в базу данных mysql -u USER -pPASSWORD DATABASE < /path/to/dump.sql Заливаем архив бекапа в базу gunzip < /path/to/outputfile.sql.gz | mysql -u USER -pPASSWORD DATABASE или так zcat /path/to/outputfile.sql.gz | mysql -u USER -pPASSWORD DATABASE Создаём новую базу данных mysqladmin -u USER -pPASSWORD create NEWDATABASE Удобно использовать бекап с дополнительными опциями -Q -c -e, т.е. mysqldump -Q -c -e -u USER -pPASSWORD DATABASE > /path/to/file/dump.sql, где: -Q оборачивает имена обратными кавычками -c делает полную вставку, включая имена колонок -e делает расширенную вставку. Итоговый файл получается меньше и делается он чуть быстрее Для просмотра списка баз данных можно использовать команду: mysqlshow -u USER -pPASSWORD А так же можно посмотреть список таблиц базы: mysqlshow -u USER -pPASSWORD DATABASE Для таблиц InnoDB надо добавлять —single-transaction, это гарантирует целостность данных бекапа. Для таблиц MyISAN это не актуально, ибо они не поддерживают транзакционность. Подробнее Общие факты Полезно под каждую базу на боевом сервере создавать своего пользователя Кодировка базы может быть любой, если она UTF8 В большинстве случаев лучше использовать движок InnoDB В php лучше забыть про сильно устаревшее расширение mysql и по-возможности использовать pdo или mysqli Новую копию MySQL всегда можно настроить и оптимизировать Без особой нужды не стоит открывать MySQL наружу. Вместо этого можно сделать проброс портов ssh -fNL LOCAL_PORT:localhost:3306 REMOTE_USER@REMOTE_HOST Работа с данными Числа На 32-битных системах практически нет смысла ставить для типа INTEGER свойство UNSIGNED, так как такие большие числа в php не поддерживаются. На 64-битных системах, php поддерживает большие числа, вплоть до MySQL BIGINT со знаком. Связанные таблицы («Foreign keys») должны иметь полное сходство по структуре ключей. Т.е. если у нас на одной таблице для поля указано «INTEGER UNSIGNED DEFAULT 0 NOT NULL» то и на другой должно быть указано аналогично Для хранения булевых значений, нужно использовать TINYINT(1) А деньги лучше хранить в DECIMAL(10, 2), где первое число обозначает количество всех знаков, включая запятую, а второе — количество знаков после запятой. Итого, у нас получится что DECIMAL(10,2) может сохранить 9999999,99 Строки В старых версиях (до 5.0.3) VARCHAR была ограничена 255 символами, но сейчас можно указывать до 65535 символов Помните, что тип TEXT ограничен только 64 килобитами, поэтому что бы сохранять «Войну и Мир» пользуйтесь «LONGTEXT» Самая правильная кодировка для вашей БД UTF8 Даты Не забывайте, что DATE, TIME, DATETIME — выводятся в виде строк, поэтому поиск и сравнение дат происходит через преобразование TIMESTAMP — хранится в виде UNIX_TIMESTAMP, и можно указать автоматически обновлять колонку Сравнивая типы данных DATETIME и TIMESTAMP, не забывайте делать преобразование типов, например: SELECT * FROM table WHERE datetime = DATE( timestamp ) Перечисления Для перечислений правильно использовать тип ENUM Правильно пишется так: ENUM('мама', 'мыла', 'раму') Можно ставить значение по-умолчанию, как и для любой строки В базе поле с перечислением хранится как число, поэтому скорость работы — потрясающе высокая Количество перечислений ~ 65 тысяч dev.mysql.com/doc/refman/4.1/en/storage-requirements... help.scibit.com/mascon/masconMySQL_Field_Types.html Отладка Если запросы тормозят, то можно включить лог для медленных запросов в /etc/mysql/my.cnf А потом оптимизировать запросы через EXPLAIN И наблюдать за запросами удобно через программу mytop ©habrahabr","tags":"copy\\paste","title":"MySQL шпаргалки"},{"url":"https://stonedastronaut.github.io/kak-vazhno-pisat-khoroshii-kod.html","text":"Мне приходится очень много читать код. Это и open source, и всяческие фреймворки, и код enterprise приложений. Именно о последних я хотел бы сегодня поговорить. Большая часть кода enterprise приложений — отстой. Приложения глючат и тормозят, их сложно тестировать, постоянно проблемы с развертыванием и обновлением. Это как бы никого не удивляет. Но удивляют люди, написавшие отстойный код. Эти люди, с немалым опытом, знают несколько языков, прочитали много книг, знают ООП, SOLID, рефакторинг, паттерны и другие малопонятные слова. То есть примерно такие, как многие из вас, читающих этот пост. Теория разбитых окон В 1969 году был проведен эксперимент. В ходе эксперимента две одинаковые машины были оставлены в двух местах – в благополучном университетском городке и неблагополучном районе крупного города. Не удивительно что в неблагополучном месте машина простояла всего пару дней и была выпотрошена, а в благополучном машина простояла нетронутой неделю. Но как только в уцелевшей машине разбили стекло, жители этого самого благополучного городка за несколько часов разобрали её на детали и перевернули вверх дном. В последствии ученые назвали это явление \"Теорией разбитых окон\". Согласно теории, любое проявление беспорядка или нарушение норм провоцирует людей также забыть о правилах. Теория получила несколько экспериментальных подтверждений и её можно считать вполне достоверной. Есть также и обратный эффект. Поддержание порядка приводит к тому, что окружающие также поддерживают порядок. Как это влияет на код В enterprise разработке прессинг сроков и неопределенности требований бывает настолько высок, что кажется сделать \"быстро и грязно\" – гораздо лучший вариант, чем сделать правильно. Моментально подход \"быстро и грязно\" начинает распространяться по всему приложению, как путем clipboard inheritance (aka copy-paste), так и за счет эффекта разбитых окон. Еще один фактор влияющий на качество кода – сложность и несовершенство платформ и фреймворков, используемых в разработке. Из-за этого в коде часто появляются хаки и нелепые workaround-ы. Со временем начинает казаться что эти хаки и есть хороший код. Даже когда проблемы фреймворков исправляют, люди продолжают использовать хаки. Кстати эти хаки со временем могут попадать в интернет через форумы, блоги или pastebin и распространяться далеко за пределы одного приложения. Вы можете сказать, что качество кода не влияет на качество приложения. Увы, еще как влияет. Программисты допускают ошибки. Чем более плохой код, тем сложнее эти ошибки найти и исправить так, чтобы не создать новых. Прессинг сроков и сложности, скорее всего, не даст написать хороший код и появится еще один хак. В open source и продуктовой разработке такое встречается реже. Там больше следят за качеством и меньше прессинг сроков. Код пишется для людей Часто программисты забывают что код программ пишется в первую очередь для людей. Даже если вы пишите программу в одиночку, то посмотрев на нее через месяц, вы не вспомните почему написали тот или иной кусок кода и за что он отвечает. Хороший код должен, в первую очередь, очень ясно выражать намерения. К сожалению \"быстрые и грязные\" способы разработки бьют в первую очередь по понимаемости кода. Улучшение кода осознанно откладывается до лучших времен, когда будет пауза чтобы провести рефакторинг. Те самые лучшие времена никогда не наступают, а код начинают читать и дорабатывать сразу же после попадания в source control. Даже если вы полностью довольны свои кодом (в большинстве случаев программисты свои кодом довольны), то подумайте о том как будет ваш код читать другой человек (в большинстве случаев программисты недовольны чужим кодом). Приверженность качеству Единственный способ добиться высокой продуктивности и эффективности – писать хороший код сразу. Единственный инструмент повышения качества кода – вы сами. Если вы не стремитесь всегда делать хороший код, то вам не помогут ни тесты, ни инструменты статического анализа. Даже ревью других программистов не поможет. Код всегда можно сделать настолько запутанным, что в нем невозможно будет найти ошибку при чтении, при этом сделать вид, что код очень важен и никто не возьмется его переписать. В первую очередь необходимо думать о структуре и именовании. Код с зашифрованными идентификаторами и малопонятным потоком исполнения скорее всего будет содержать ошибки. Не допускайте такого кода, это гораздо дешевле, чем исправлять ошибки. Ясно выражайте намерения в своем коде, сводите к минимуму неочевидные неявные аспекты. Не надо стремиться сделать код максимально лаконичным, стремитесь сделать его максимально понятным. Если вам приходится править код, то не создавайте хаков. Потратьте немного времени, напишите нормально. Сэкономите на поддержке. Если же код совсем плохой, был сделан \"быстро и грязно\" и оброс хаками, то просто выкиньте его и перепишите. Только не надо пытаться переписать все. Учитывайте продуктивность: программист пишет 40-60 отлаженных строк кода в день в нормальном темпе и 120-200 в ускоренном (высокая концентрация, четкая цель, понятно что делать). Если вы сами пишете \"быстро и грязно\", например прототип для уточнения требований, то выкиньте код и перепишите нормально сразу после того, как ваш код сделает свое дело. Если вы скопировали часть кода из другого места или, не дай бог, из интернета, то разберитесь как он работает, прежде чем заливать изменения в source control. Вообще не используйте непонятные для вас фрагменты кода. Всегда поддерживайте чистоту и порядок в вашем коде, пользуйтесь инструментами, которые помогают вам это делать. Не будете этого делать – код очень быстро превратится в помойку. Собирайте статистику по плотности проблем в коде, это поможет вам лучше понять, как писать хороший код. Перечитывайте свой код. Проводите рефакторинг постоянно в процессе написания. Помните, что рефакторинг \"потом\" никогда не наступает. Думайте о том, какой код вы хотите написать, до того как начать его писать. Само написание кода – настолько поглощающий процесс, что думать о качестве некогда. Состояние потока – это состояние свободы самовыражения. Необходимо заранее ограничить самовыражение, чтобы код получился хорошим. Экономика качества кода Ошибка найденная и устраненная на этапе кодирования в 10 раз дешевле, чем ошибка найденная при тестировании и в 100 раз дешевле ошибки, найденной в production. В истории есть реальные примеры ошибок, исправление которых обошлось в десятки тысяч долларов. Поэтому очень важно устранять ошибки на этапе разработки, причем усилиями самих разработчиков. Напоследок Не путайте хороший и идеальный код. Идеального кода не существует, нет смысла заниматься бесконечным улучшением в стремлении к идеалу. Хороший код – это код который читаем, понятен, решает задачу, правильно структурирован и не содержит ошибок. Писать хороший код не просто ваша цель, это ваша обязанность. ©habrahabr","tags":"copy\\paste","title":"Как важно писать хороший код"},{"url":"https://stonedastronaut.github.io/pochemu-programmisty-rabotaiut-po-nocham.html","text":"Согласно поговорке, программисты — это устройства, преобразующие кофеин в код. Если спросить первого попавшегося программиста, когда он наиболее продуктивен, — скорее всего, он назовёт ночь. Кто-то пораньше, кто-то попозже. Популярен вариант встать в 4 утра и сделать работу до начала дневной суматохи. А некоторые предпочитают ложиться в 4 утра. Цель всего этого — избавиться от отвлекающих факторов. Но можно было бы просто закрыть дверь… Что же такого особенного в ночи? Я думаю, что всё сводится к трём вещам: расписанию творца, сонному мозгу, и яркому экрану компьютера. Расписание творца В 2009 году Пол Грэм написал о «расписании творца» (maker's schedule). По его мнению, в мире есть два основных типа расписаний. В традиционном «распорядке менеджера» день разделяется на отдельные часы, и десятиминутная помеха обходится максимум в час потерянного времени. Часовой механизмДругой вариант Грэм называет расписанием творца — того, кто что-то создаёт, творит, производит. Работа над большими абстрактными системами требует размещать их целиком в своей голове. Это можно сравнить с постройкой дома из хрусталя: стоит отвлечься, как всё осыпается и разбивается вдребезги. Поэтому программистов так раздражает, когда их отвлекают. Из-за этого огромного умственного вклада мы просто не начинаем работать, пока не можем рассчитывать на пару часов покоя. Не имеет смысла строить в голове всеобъемлющую модель системы только для того, чтобы через полчаса её кто-то сломал. В самом деле, поговорив с руководителями компаний вы узнаете, что они просто не могут закончить никакую работу в течение дня. Постоянная канонада помех: важных дел™, требующих внимания, и писем, требующих ответа, — просто не позволяет что-либо сделать. Поэтому они выполняют бо́льшую часть работы ночью, когда все остальные спят. Сонный мозг Но даже программистам нужно спать по ночам. Мы не какие-нибудь суперлюди. Даже программисты более внимательны именно днём. Пик БалмераТогда почему же мы выполняем самую сложную умственную работу когда мозг хочет спать, а более простые задания — когда разум остр и ясен? Потому что усталость делает нас лучшими кодерами. Как с пиком Балмера, усталость заставляет нас собраться потому, что уставший мозг просто вынужден сосредоточиться! У него элементарно не остаётся лишних сил, чтобы позволить себе потерять концентрацию. Например, моя продуктивность минимальна после чрезмерного количества чая или невовремя выпитого энергетического напитка: они делают меня гиперактивным, и я то проверяю твиттер, то читаю Hacker News, — в общем, просто прыгаю туда-сюда. Казалось бы, я должен работать лучше — столько энергии, такой разогнанный мозг. Однако, вместо этого я сам путаюсь у себя в ногах, потому что не могу сконцентрироваться больше чем на две секунды. С другой стороны, когда я немного уставший, я просто плюхаюсь за стол и пишу. Со слегка утомлённой головой я могу писать код часами, даже не думая заглянуть в твиттер или фейсбук. Интернет как будто перестаёт существовать. Мне кажется, это верно для большинства программистов. Наши умственные силы избыточны для ~80% задач: согласитесь, реализация интересного алгоритма часто требует написания ещё раз в десять большего объёма вспомогательного кода. Даже если вы занимаетесь самым сложным машинным обучением, какое только можно представить, большой кусок работы — это просто подготовка данных и вывод результатов в красивом видe. А когда мозг не работает на полную мощность, он ищет какое-нибудь занятие. Усталость притупляет разум настолько, что ему становится достаточно и одной текущей задачи. Яркие экраны компьютеров Здесь всё просто. Продолжайте вечерами пялиться на яркий источник света, и ваш режим сна начнёт задерживаться. Вы забываете об усталости до трёх часов ночи, потом просыпаетесь в 11, и когда наступает вечер — вы просто ещё не устали, потому что на ногах всего с одиннадцати утра! Ночной Инсбрук После нескольких повторений такой подход запросто утащит вас в другой часовой пояс. Что интересно, сдвиг не бесконечен, и однажды попав в равновесную точку отхода ко сну между 3 и 4 часами, вы, как правило, там и останетесь. А быть может, дело в будильниках, поднимающих нас по утрам, — потому что общество называет нас паршивыми лентяями, если мы начинаем завтрак в два часа пополудни. Заключение Итак, программисты работают по ночам, потому что это не требует прекратить работу к определённому времени (что позволяет работать более расслабленно), мозг не отвлекается, а яркий экран прогоняет сон. ©megamozg","tags":"copy\\paste","title":"Почему программисты работают по ночам"},{"url":"https://stonedastronaut.github.io/kak-vozrodit-poteriannuiu-motivatsiiu.html","text":"Вы потеряли ту страсть, которая была у вас к программированию? Влияет ли это на мотивацию завершать свои задачи? Трудно ли вам заканчивать проекты? Если да, то для вас есть хорошие новости: это случается с каждым, так что не отчаивайтесь. Представьте, что костёр в вашем лагере потух. Вместо того, чтобы переживать об этом, лучше успокоиться, глубоко вздохнуть и подумать о том, как снова его зажечь. Это может быть не легко, но это возможно. Если вы не будете торопиться, то всё будет хорошо. Проводите время с программистами-единомышленниками Когда вы чувствуете безразличие и скуку, худшее, что можно сделать — это страдать в одиночестве. Если вы ещё не окружены единомышленниками, вам стоит поискать сообщество. Личное общение идеально, но онлайн-взаимодействие лучше, чем ничего. Нужно прояснить: речь не идёт о том, достаточно ли вы сильны для того, чтобы самому тянуть себя вперёд. Быть немотивированным не значит быть слабым. Просто важно сохранять связь с реальностью, а это сложно, если вы не видите свою ситуацию со стороны благодаря другим программистам. Помните: цель не в том, чтобы жаловаться и делиться своей печалью. Это плохо и к тому же может понизить мотивацию других людей. Цель в том, чтобы поделиться своим беспокойством, или может быть мелочами, которые убивают ваше вдохновение. Если вы не уверены в себе или чувствуете дискомфорт, будет полезным найти наставника. Наставник может проверять качество вашего кода и давать обратную связь. Также он может быть внешним мотиватором, когда вы захотите сдаться. Меняйте темы и изучайте новое Во многих случаях мотивация падает из-за скуки. Если вы долго работали разработчиком ПО, вы можете ощущать себя застрявшим на бесперспективной работе. Может быть, код, с которым вы работаете, тривиальный и не требует умственного напряжения. Что делать? Нужно переключиться. Половина удовольствия от программирования приходит от решения творческих задач. Без этого программирование превращается в рутину, особенно если написание кода даётся легко. В зависимости от возможностей вашей фирмы, попросите руководителя переключить вас на другой проект. Если вы можете себе позволить, переключитесь на другую область (например, вы могли писать образовательное ПО под Windows, а теперь попробовать писать социальные сети). Или вы можете выбрать несколько сторонних хобби-проектов, где используются новые для вас области программирования. Например, попробуйте сделать мобильную игру в свободное время. Вы можете быть удивлены тем, как много энергии могут дать вам личные проекты. Главное, убедитесь, что сторонние проекты значительно отличаются от того, чем вы итак занимаетесь. Развивайте умственное и эмоциональное здоровье Недостаток мотивации может быть симптомом более глубокой проблемы, начиная с обезвоживания и заканчивая депрессией. Иногда глотка воды достаточно, чтобы вернуть себе вдохновение. Но если недостаток мотивации проявляется долгое время, лечение может оказаться не таким простым. Для компьютерных профессий, таких как программист, нужно соблюдать 3 принципа касательно здоровья. Во-первых, надо регулярно заниматься физическими упражнениями. Если времени мало, можно выполнять простые упражнения на рабочем месте. Во-вторых, минимизируйте своё утомление от компьютера. В-третьих, нормализуйте свой сон. Умственная усталость также является следствием статичности окружающей обстановки. Смотреть на одни и те же 4 стены каждый день довольно монотонно. А монотонность ведёт к скуке. Это можно вылечить сменой вашей обстановки, например путём перестановки мебели, смены места или хотя бы фона рабочего стола. Наконец, недостаток мотивации часто связан с промедлением в выполнении задач. Здесь очень полезной окажется техника Pomodoro. Она разделяет ваш рабочий день на периоды работы и отдыха. Никогда не пробовали? Потестируйте хотя бы 1 или 2 недели. Результаты могут вас приятно удивить. Выводы Программирование — это весело! Программирование — это скучно. Это снова весело! Это снова скучно. Каждый раз эти ощущения несколько разные, но советы, описанные выше, всегда работают. Ещё одна вещь, которая может вам помочь — это онлайн-соревнования по программированию. Это потребует определённых личностных качеств, но дух соревнования может возродить и поддерживать в вас страсть. Перевод «Programming Burnout: How to Regain Your Lost Motivation» ©tproger","tags":"copy\\paste","title":"Как возродить потерянную мотивацию"},{"url":"https://stonedastronaut.github.io/vy-razrabotchik-tak-pochemu-vy-do-sikh-por-na-kogo-to-rabotaete.html","text":"Как разработчик, вы сидите на золотой жиле. Вы осознаете это? Нет, серьезно, на @#$% золотой жиле! Никогда в истории не существовало возможностей так легко создать что-то с нуля, с маленьким или отсутствующим начальным капиталом и маркетинговой моделью, ограниченной только вашим воображением. Подумайте о крупнейших сайтах, которые вы постоянно посещаете: Facebook, Twitter, Flickr, Foursquare, или даже Google — все они были созданы разработчиками, у которых была лишь идея. Было ли это легко? Черт, нет. Но это могло быть сделано только в наше время. Так, черт побери, почему вы просиживаете день за днем, работая на кого-то? Да, я тоже наемный работник. И я ненавижу это. Если вокруг есть столько прекрасных возможностей, почему большинство разработчиков не работают на себя? Я думаю, есть несколько отговорок, которые мы придумываем сами себе. Но ни одна из них не является серьезной. Миф №1: у вас нет времени Я часто слышу эту отговорку и каждый раз смеюсь. Сколько времени вы проводите за телевизором или игрой в XBox, Wii, Playstation и так далее? От силы час в день, так? А сколько времени вы проводите в Facebook'е и Twitter'е? (Скорее всего, минутку сейчас, минутку потом?) А что вы делаете каждый день в обеденный перерыв? Это ведь целый час времени. Вот что я скажу: час тут, час там — у вас на самом деле есть время. Суть в том, как вы его проводите. Если вы действительно хотите что-то сделать, вам нужно найти идею (действительно хорошую идею) и загореться ею! Если вы увлечетесь чем-то, вы найдете время. И в итоге придете к тому, что вам некомфортно работать над чем-то кроме вашей идеи. Мне 31 год, я женат, и у нас трое маленьких детей. Я целый день работаю, а потом прихожу домой к чудесной жене, которая к концу дня не знает, куда деваться от детей. Я считаю себя довольно занятым человеком, но тем не менее мне удается находить как минимум 20 часов в неделю для того чтобы поработать над моей идеей, которая поможет мне освободиться из зарплатной ловушки, куда я сам себя заманил. Я пишу этот текст сидя в уютном кресле в кафе через дорогу от моей работы. Я захожу сюда практически каждый день, и это составляет почти 5 дополнительных часов продуктивной работы в неделю! Никаких бегающих детей вокруг, никаких отвлекающий факторов, только я, мой лэптоп и мои наушники. Миф №2: я не могу придумать идею Если вы только начинаете работу, вы постоянно слышите от людей фразы типа «Идеи ничего не стоят» и «Я легко могу придумать идею, просто у меня нет времени на реализацию». Когда вы сидите и пытаетесь придумать Очередную Клевую Штуку (очередной Facebook, очередной Reddit и т.д.), вам кажется, что все хорошие идеи уже реализованы! И вы не можете придумать ничего стоящего. Попросите основателя любого крупного веб-сайта сравнить текущее положение дел с тем, каким он его представлял, и, я уверен, он рассмеется. Все они вряд ли пошли тем путем, которым собирались пойти. Сейчас эти сайты имеют огромную посещаемость благодаря тому, что их создатели были достаточно умны, чтобы улучшать и создавать функции, которые нравятся пользователям. Поэтому перестаньте пытаться сделать хоумран (прим. пер. — в бейсболе удар через все поле, позволяющий набрать очко), лучше попытайтесь сперва добежать до базы! Создайте что-то полезное. Что-то, что нужно людям, а затем улучшайте это, снова и снова. Начните с простого и развивайте. Если вы чересчур увлечены конечным результатом (яхта и частный остров в Карибском море), то вы всего лишь фантазер. Сделайте что-нибудь, покажите это людям, получите отзывы и улучшайте. Вот что я делаю, когда пытаюсь придумать новую забавную идею для работы: 1. Слушаю National Public Radio (или любое другое ток-шоу). Люди обожают жаловаться. Я смотрю на любую жалобу как на возможность! Например, мой текущий проект родился во время празднования столетия движения бойскаутов. Я сам бывший бойскаут, был лидером скаутов. Однако я успел позабыть обо всех сложностях. Радиопередача подкинула мне идею, над которой я сейчас работаю. Это довольно узкая ниша, но она предоставляет много возможностей. Еще мне приходит на ум много плохих идей, но это нормально! Это как упражнение. Чем больше вы открыты, тем легче мысли приходят в голову и тем легче оценивать их. Найдите то, что люди ненавидят, что доставляет им неудобство, и сделайте что-то, за что они захотят заплатить (неважно, напрямую или косвенно). 2. Чем вы любите заниматься? Что вам больше всего нравится? Займитесь тем, что вам нравится, иначе вскоре это может действительно надоесть, и вам будет хотеться заняться чем-то другим. Перед тем, как вы начнете, убедитесь, что вы готовы думать о вашей идее круглые сутки в течение недели, иначе у вас ничего не получится. Одно из моих увлечений — погружение с аквалангом. Я бы очень хотел жить в мире, где не нужно думать ни о чем другом, кроме погружений. Так что у меня есть несколько идей в этой области, которые я пока обдумываю. 3. Ведите записи. Google Docs вам в помощь. У меня есть документ, который я называю «Идеи для моих программ». Когда у меня появляется идея — не важно насколько она тривиальна или уникальна — я немедленно записываю ее в этот документ. Некоторые люди для этой цели держат блокноты на прикроватной тумбочке. Даже не знаю, сколько раз за рулем у меня возникали идеи, а к тому времени, когда я добирался домой, забывал их. Не то что бы это были плохие идеи, просто я отвлекался и забывал о них. Через некоторое время они возвращались ко мне, однако было все равно неприятно. Ведение записей позволит вам упорядочивать ваши идеи, добавлять к ним заметки и размышления. Никогда не начинайте работу в тот же день, как придумали идею. Обдумайте ее по крайней мере день или два. Убедитесь, что она стоит того, чтобы потратить на нее следующие несколько лет вашей жизни. Не делайте что-то ради того, чтобы посмотреть, понравится ли это людям. Сперва прочтите «Да, но кто вам сказал, что они КУПЯТ эту штуку?» (прим. пер. — ссылка ведет на непереведенную статью) и возвращайтесь. Давайте, я подожду. Миф №3: у меня нет денег Кто сказал «деньги»? Только если ваша идея совершенно точно требует вложений, что является довольно редким явлением в Интернете, вы можете начать с нулем. Нуль. Ничего. Ничегошеньки. Будьте изобретательны, чтобы достигнуть нужного результата. Меняйтесь, продавайте, консультируйте. Возьмите за правило тратить как можно меньше, чтобы добиться результата. А лучше не тратьте деньги вообще до тех пор, пока не станете получать их от своих клиентов. Я потратил кучу денег на хостинг для Django в моем текущем проекте. Хостинг мне нравится, однако я считаю это роскошью. Я мог бы использовать Google App Engine бесплатно, но черт, я способен потратить сто баксов в год. Я планирую использовать бесплатный Chargify до тех пор, пока не стану получать от проекта достаточно денег, чтобы тратить их на хостинг. Для старта вам не нужны деньги. Если вы думаете иначе, и особенно если вы впервые занимаетесь своим делом, вам стоит подумать еще раз. Миф №4: я ничего не знаю о маркетинге/дизайне/и т.п. Это не самая лучшая отговорка от старта своего дела, однако самая популярная. Как разработчик, я прихожу в ужас от того, что нужно продавать. Я ненавижу висеть на телефоне. Я не люблю думать о том, как бы привлечь побольше народу на мой сайт. Я люблю создавать что-то. Если сейчас вы соглашаетесь со мной, то у вас есть два пути: 1. Найдите партнера, который разбирается в том, в чем не разбираетесь вы. Сосредоточьтесь на том, что вы делаете хорошо. Если вы разработчик, слушайте, что говорят пользователи и тратьте все свое время на создание действительно классного продукта. Продажи и маркетинг могут отнять все свободное время. Это действительно трудно управляться с обоими направлениями. Если у вас два партнера-технаря, мы можете разделить между собой задачи по продажам и маркетингу, и в конце концов обнаружите, что тот, кто справляется с ними лучше, будет ими заниматься все время. Однако тот факт, что вы «разработчик», не означает, что вы не должны участвовать в продажах или маркетинге! Хотя на сильных сторонах необходимо сосредотачивать свои усилия, однако также нужно знать, как работают продажи, маркетинг, PR и все с этим связанное. Это предотвратит фразы типа «Черт, почему Джон не может привести ни одного клиента? Мне кажется, что я делаю всю работу.» Вы станете больше ценить продажи и маркетинг после того, как узнаете, насколько тяжело ими заниматься! Давайте! Не будьте бабой! (Дамы, прощу прощения за выражение.) И наоборот, дайте вашему партнеру, который соображает в продажах или маркетинге, просмотреть код хотя бы по диагонали. Устройте этакое сотрудничество. По крайней мере, если он будет знать, сколько времени занимает ваша работа, он сначала проконсультируется с вами насчет новой фичи, а не пойдет продавать несуществующую функциональность. Уберите завесу тайны и вникайте в дела друг друга! 2. Не будьте тряпкой и научитесь этому! Это значит, что вам нужно будет отложить код в сторонку и научиться продавать и стать настоящим продажником или пиарщиком. Это потребует времени, только не сдавайтесь! Хорошая новость: что то, что работает для одной компании или сайта, необязательно будет работать для другой. Что? Это больше похоже на плохую новость? Взгляните на это с другой стороны: худшее, что вы можете сделать, это не справиться. Я иронизирую, но это правда. Если вы провалитесь в маркетинговой компании, что тогда? ПОПРОБУЙТЕ сделать это другим способом. Добавьте неудачный вариант в список плохих способов и двигайтесь дальше. Изучите книги, форумы, сайты, руководства, а затем идите и ЭКСПЕРИМЕНТИРУЙТЕ. Для этого вам даже не нужны деньги. Будьте изобретательны и находчивы. Вам нужно узнать, какой подход работает именно для вас, а не для кого-то другого. Учитесь и пробуйте. Миф №5: я не могу бросить работу — мне нужен стабильный доход Это больше похоже на реальную причину, нежели на отговорку, однако зачем мириться с существующим положением вещей? Вы действительно хотите до конца жизни каждый день на кого-то работать, соглашаясь с предложенными условиями? Нет? Ну что ж, тогда придется чем-то пожертвовать. И вы об этом знаете, иначе не читали бы эту статью! При малейшей возможности лучшее что вы можете сделать — уйти с работы и уделять 100% времени вашему стартапу. Это заставит вас сосредоточиться на продукте и сделать что-то, за что люди заплатят. Необходимость оплачивать счета и покупать еду — это очень хорошие мотиваторы. Если у вас тоже есть дети и уход с работы невозможен, вы все равно можете найти время. Просто проект займет больше времени. Смотрите «Миф №1: у вас нет времени». Все большие стартапы не делались за одну ночь. Иногда потребуются годы, чтобы чего-то достичь. Главное не сдаваться! Как только у вас появится работающий прототип, вам нужно пойти к людям, которые говорили, что идея хорошая, и узнать, что они думают о вашем продукте. Это действительно придает сил. Найдутся и те, кому ваш продукт не понравится, однако не принимайте это близко к сердцу. Учтите критику и сделайте ваш продукт еще лучше. Худшее, что может случиться, это люди, которые говорят приятные вам вещи только потому, что не хотят обидеть вас. В таком случае у вас получится заурядная вещь, которая никому не нужна. После того, как вы начали получать отзывы и привлекать пользователей, начните привлекать инвестиции в ваш проект. Просите об этом знакомых, общайтесь с бизнес-ангелами. Даже если вам не удастся убедить их вложить деньги, это еще не означает, что ваша идея плоха, это означает, что вы должны улучшить ее и привлечь больше пользователей. Если вы можете привлечь и удержать людей, значит вы чего-то стоите. В наше время необязательно иметь хорошо проинвестированный или модный проект, чтобы зарабатывать деньги! Миф №6: я не могу найти партнера Плохое партнерство — самая частая причина провала стартапов. Ссоры или партнеры, которые не вкладываются в работу, убивают дело очень быстро. Очень важно найти такого же увлеченного партнера, как и вы. Не думайте, что кто-то сразу загорится вашей идее так же сильно. Вы гораздо дольше размышляли и мечтали о ней. При обсуждении идеи критика и игра в «адвоката дьявола» приветствуются. Вы действительно думаете, что ваше мнение — это мнение всех? Поэтому приветствуйте несогласия и расхождения во взглядах, по крайней мере до тех пор, пока они не выходят за пределы конструктивной критики. Где искать хорошего партнера? Лучше всего среди знакомых вам людей. Таким образом снижается риск несовместимости, потому что вы уже знаете людей, их привычки и пристрастия. Также вам необходим тот, кто понимает, что в начале пути стартап предполагает тяжелую работу и маленькую отдачу. Участвуйте в сообществах, таких как Hacker News и Founders Mix, чтобы найти подходящих вам людей. Если недалеко от вас проходят встречи Gangplank, сходите потусите там. Послушайте, что говорят люди, и не бойтесь поделиться с ними своей идеей. Не пытайтесь угадать, что нужно людям, а СПРОСИТЕ их об этом прямо! Это глупо болтаться рядом и бояться высказать вслух свою идею, потому что «они могут украсть ее». Идеи ничего не стоят. Если вы думаете, что кто-то может реализовать ваши задумки лучше, у вас большие проблемы. А теперь возьмите и сделайте что-то, что нужно людям! ©megamozg","tags":"copy\\paste","title":"Вы разработчик? Так почему вы до сих пор на кого-то работаете?"},{"url":"https://stonedastronaut.github.io/9-rasslabliaiushchikh-saitov-dlia-podderzhaniia-spokoistviia-i-khoroshego-nastroeniia.html","text":"Две минуты безделья на DoNothingFor2Minutes.com . Дождливое настроение на Rainy Mood . Спокойствие и только спокойствие на Calm.com . Просто шум на SimplyNoise . Просто дождь на SimplyRain . Вы в кафе на Coffitivity . Звуки природы на naturesoundsfor.me . Поток музыки Focus@Will , которая увеличивает внимание. Оптимистичная музыка на Get Work Done Music .","tags":"unsort","title":"9 расслабляющих сайтов для поддержания спокойствия и хорошего настроения"},{"url":"https://stonedastronaut.github.io/7-tipichnykh-oshibok-neopytnykh-programmistov.html","text":"Сколько люди будут учиться программированию, столько будут совершать одни и те же ошибки. Существуют грабли, на которые просто невозможно не наступить. Тем не менее небольшая ошибка в начале разработки может обернуться сильной головной болью для программиста и его коллег в будущем. Хочется верить, что читатели этой статьи смогут сократить количество неверно принятых решений в ходе разработки программ до минимума. Неумение кататься на велосипедах Неожиданно, да? На самом деле мы хотели сказать, что в эпоху дот-нетов, мак буков и web 2.0 всё (ну или почти всё) уже написано. На любой более-менее популярный язык программирования — по несколько фреймворков и сред разработки, в том числе множество бесплатного, но качественного софта и огромное количество CMS'ок и движков сайтов, для коих, в свою очередь, тысячи плагинов, расширяющих их функционал. Но начинающие программисты часто либо забывают про этот факт, либо его игнорируют. Они, может быть, и понимают, что кто-то уже решил задачу, которая перед ними стоит, и предлагает решение абсолютно бесплатно, но это почему-то не останавливает их от изобретения велосипедов, которые в большинстве случаев оказываются менее качественными, чем существующие. А ведь вместо придумывания лучше найти хороший пример с открытым кодом и сосредоточиться на других задачах. Использование неподходящих средств разработки Знаете, некоторые прям-таки с гордостью заявляют, что пишут веб страницы в блокноте Windows. По их мнению, этим фактом они подчеркивают некий аскетичный стиль программирования, которому следуют, а на самом деле — еще раз демонстрируют свою глупость. Опять же, в наше время существует множество удобных сред и средств разработки, которые упрощают написание кода, заранее проверяют в нём ошибки, выдают подсказки и прочее, и прочее. Зачем пренебрегать имеющимися благами программирования? Видимо для того, чтобы сделать больше ошибок и потратить лишнее время на отладку — иных причин я не вижу. Используйте блокнот как блокнот. Вопросы, на которые уже 100 раз ответили Перед тем, как начать спрашивать что-либо на форумах и в сообществах, просто поищите ответ на свой вопрос. Если Вы начинающий программист, то наверняка кто-то до Вас уже интересовался тем, что Вам непонятно. Сначала ищите информацию в мануалах, документации, на форумах, в разделах FAQ, а только потом, в случае неудачи, спрашивайте у других. Костыли У новичков код пестрит неочевидными ходами и решениями. Некоторые из них появляются в результате того, что при тестировании программа начинает вести себя не так, как ожидается. Вместо того, чтобы докопаться до сути проблемы, неопытный программист на скорую руку начинает вставлять в код заплатки, которые уродуют программу. Доходит до смешного. Например, на сайте была форма, куда пользователь должен был ввести число от 0 до 999. Вместо того, чтобы получить из поля данные и проверить, действительно ли это число находится в заданном диапазоне, человек сделал проверку на количество символов не больше трех. В итоге в логике программы становится трудно разобраться. Ещё сложнее становится вносить изменения и расширять функционал. «Этого точно никогда не будет» Любимый прием новичка – игнорировать обработку некорректных входных данных. Мотив: «Этого точно никогда не будет». А ведь будет наверняка! Закон программистской подлости — случится именно то, чего ты не предусмотрел. Надо быть готовым, что там, где должны ввести год рождения, будут вводить все, что угодно, кроме нужных четырех цифр. При этом еще нужно придумать правильные ограничивающие условия. Некрасивый код Стоит ли говорить, что вначале многие не задумываются о длине строчек кода, размере функции, забывают о комментариях и т.д. Не задумываются в основном потому, что не имеют опыта длительной разработки, когда начинаешь понимать, что всё то, что на первый взгляд кажется мелочью, на самом деле очень важно для жизнеспособности программы в дальнейшем. Не получилось с первого раза — ищем простой путь Наверное, все за собой замечали: по какой-то непонятной причине программа работает некорректно, а в чем дело — мы никак определить не можем. Тогда мы и начинаем подставлять костыли из пункта 5. Например, есть файл с объявлениями констант и функциями, который используют разные модули программы. В одном модуле этот файл забыли включить, что в ходе выполнения привело к выводу ошибки интерпретатором о том, что не нашлась константа с таким-то именем. Вместо того, чтобы разобраться, где она объявлена и почему не нашлась, мы берем и ещё раз объявляем её в проблемном модуле. Это очень плохое решение. Не делайте так, ищите корень проблемы. Учимся на своих ошибках и не забываем: хорошо написанная программа – плюс один в карму! ©GeekBrains","tags":"copy\\paste","title":"7 типичных ошибок неопытных программистов"},{"url":"https://stonedastronaut.github.io/izvlechenie-kliuchei-rsa-metodom-akusticheskogo-kriptoanaliza.html","text":"Известный криптограф Ади Шамир с коллегами опубликовал научную работу под названием «Извлечение ключа RSA путем криптоанализа с низкой частотой дискретизации» (http://www.tau.ac.il/~tromer/papers/acoustic-20131218..). Многие компьютеры издают высокочастотный звук во время работы, из-за вибрации в некоторых электронных компонентах (конденсаторах) из-за микроскопического изменения напряжения в CPU при различной нагрузке на него. Теоретически, эти звуковые колебания можно проанализировать и получить информацию о запущенном программном обеспечении, в том числе о криптографических вычислениях. В 2004 году Шамир с коллегами доказали (http://www.cs.tau.ac.il/~tromer/acoustic/ec04rump/), что разные ключи RSA вызывают разные звуковые паттерны, но тогда было непонятно, как извлекать отдельные биты ключей. Основная проблема заключалась в том, что звуковое оборудование не способно записывать звук с достаточно высокой частотой дискретизации: всего лишь 20 КГц для обычных микрофонов и не более нескольких сотен килогерц для ультразвуковых микрофонов. Это на много порядков меньше частоты в несколько гигагерц, на которой работают современные компьютеры. Теперь удалось создать программное обеспечение, которое извлекает полные 4096-битные ключи GnuPG с компьютеров различных моделей после часа прослушивания, если компьютер все это время осуществляет дешифровку. Проведена успешная демонстрация подобной атаки при помощи смартфона, который лежал в 30 см от компьютера. При использовании направленных микрофонов атаку можно проводить с расстояния до 4 метров. Если использовать миниатюрные скрытые микрофоны, то максимальное расстояние составляет около 1 метра. Все оборудование на фотографии, кроме микрофонов, можно спрятать под стол или в другом месте. Кроме акустики, подобную атаку можно осуществлять, замеряя электрический потенциал компьютерного корпуса. Для этого соответствующим образом экипированному злоумышленнику достаточно дотронуться до корпуса голой рукой либо подключиться к контактам заземления на другом конце кабеля VGA, USB или Ethernet.","tags":"crypt","title":"Извлечение ключей RSA методом акустического криптоанализа"},{"url":"https://stonedastronaut.github.io/awk-sed-bzip2-grep-wc-na-vsekh-iadrakh.html","text":"Существует такая проблема: вы хотите добавить огромный список (сотни мегабайт) или запустить поиск по регулярному выражению ( grep ) на нем, или совершить какую-то еще трудно распараллеливаемую операцию. У вас, вероятно, есть четыре ядра или даже больше, но наши проверенные и надежные инструменты grep , bzip2 , wc , awk , sed и т.д. однопоточные и будут использовать всего одно ядро. Как сказал бы Картман, «Как мне добраться до этих ядер?» Давайте использовать все четыре ядра нашей Linux-машины с помощью GNU Parallel , небольшой map-reduce магии и малоизвестного параметра --pipes (также известного как --spreadstdin ). Поверьте, удовольствие от работы прямо пропорционально количеству задействованных ядер! BZIP2 bzip2 сжимает лучше, чем gzip , но он такой медленый! К счатью, эта проблема решаема. Просто вместо этого: cat bigfile.bin | bzip2 --best & gt ; compressedfile.bz2 можно написать вот это: cat bigfile.bin | parallel --pipe --recend '' -k bzip2 --best & gt ; compressedfile.bz2 GNU Parallel особенно ускоряет bzip2 за счет работы на нескольких ядрах. Дайте ему свободу и вы будете вознаграждены. GREP Если у вас имеется огромный текстовый файл для прогона grep 'ом, то лучше используйте вместо этого: grep pattern bigfile.txt вот это: cat bigfile.txt | parallel --pipe grep 'pattern' или это: cat bigfile.txt | parallel --block 10M --pipe grep 'pattern' Вторая рекомендуемая команда показывает, как использовать команду --block с 10 MB данных из вашего файла. С этим параметром можно поиграться, чтобы понять, какой объем данных вы хотите обрабатывать одним ядром. Вот здесь можно посмотреть, как обрабатывать grep'ом не один файл, а несколько. AWK А вот это пример того, как с помощью awk добавить числа в очень большой файл. Вместо этого: cat rands20M.txt | awk '{s+=$1} END {print s}' попробуйте это: cat rands20M.txt | parallel --pipe awk \\' { s+ = \\$ 1 } END { print s } \\' | awk '{s+=$1} END {print s}' Здесь --pipe позволяет использовать несколько чанков для вызова awk , записывая промежуточные результаты, а которые затем сливаются в конечный. WC Хотите запустить супер-распараллеленный подсчет строк в файле? Тогда вместо этого: wc -l bigfile.txt запустите вот это: cat bigfile.txt | parallel --pipe wc -l | awk '{s+=$1} END {print s}' Вот это уже здорово. Что происходит? При распараллеленном вызове мы направляем несколько вызовов wc -l , формируя промежуточные результаты, а затем вызываем awk. SED Захотелось сделать огромное количество перемещений в большом файле? Тогда забудьте об этом: sed s&#94;old&#94;new&#94;g bigfile.txt и используйте вот это: cat bigfile.txt | parallel --pipe sed s&#94;old&#94;new&#94;g ... и затем направьте вывод в ваш любимый файл. source","tags":"linux","title":"awk, sed, bzip2, grep, wc на всех ядрах"},{"url":"https://stonedastronaut.github.io/strokovyi-pul-java.html","text":"Строковый пул, или множество строк, Java располагается в области памяти, именуемой Java Heap – куча , в которой хранятся все переменные, созданные программно вашим приложением. Естественно, появление этой структуры связано с оптимизацией способов хранения строк как объектов в языке. Тип String – один из самых часто используемых в Java и довольно дорогой для хранения: 4 -символьная строка занимает 56 байт памяти, т.е. реальные данные (4 символа) занимают только 14% выделенной под объект памяти. В связи с этим возникает необходимость оптимизировать способ хранения строк в памяти виртуальной машины. Так, было решено использовать подход Flyweight ( приспособленец ): если используется множество одинаковых данных (объектов), то гораздо экономнее создать только один экземпляр, чем несколько копий. 1. Работа пула на примерах. Давайте рассмотрим следующий пример: public class StringConcatenationExample { public static void main ( String [] args ) { String str1 = \"abc\" ; String str2 = \"abc\" ; System . out . println ( str1 == str2 ); System . out . println ( str1 == \"abc\" ); } } Выводом этого фрагмента кода будет следующее: true true Как видите, str1 и str2 ссылаются на один и тот же объект (т.к. равенство == будет достигнуто только в случае равенства ссылок). Изобразить это можно следующим образом: Как видите, если вы создаете новый объект String и вручную, т.е. литерами, задаете его значение ( \"Hello, world\" ), а объект с таким значением уже есть в пуле, то новая строка не создается, а просто переменная, являющаяся указателем, ссылается на уже созданный объект с тем же значением. Равенство, естественно, проверяется методом String.equals(String) . Таким образом, строковые переменные, имеющие при инициализации одинаковые значения, будут указывать на один и тот же объект. Теперь вы понимаете, почему строки в Java являются неизменяемыми: если бы в одном потоке была создана строка, и с таким же значением в другом потоке была бы создана еще одна строка, то изменение строки в одном из потоков повлекло бы ее изменение в другом. Сравним результат выполнения предыдущего фрагмента кода с этим: public class StringConcatenationExample { public static void main ( String [] args ) { String str1 = \"abc\" ; String str2 = \"abc\" ; String str3 = new String ( \"abc\" ); System . out . println ( str1 == str2 ); System . out . println ( str1 == str3 ); } } Вывод в данном случае будет: true false т.к. объекты, на которые указывают str1 и str3 уже отличаются, ведь для создания str3 был вручную вызван конструктор ( new ), что повлекло создание нового объекта. И теперь этот объект помещается не в строковом пуле, а в \"обычном\" сегменте памяти JVM. Теперь рассмотрим такой пример: public class StringConcatenationExample { public static void main ( String [] args ) { String str1 = \"abc\" ; String str2 = \"ab\" ; str2 = str2 + \"c\" ; System . out . println ( \"str1 :\" + str1 + \", str2 :\" + str2 ); System . out . println ( str1 == str2 ); } } Вывод: str1 : abc , str2 : abc false Как было указано выше, строки в Java, как объекты, изменить нельзя. Поэтому когда в коде программы мы \"изменили\" str2 на самом деле был создан новый объект-строка с новым значением. При этом str1 , очевидно, остался указывать на тот же объект, что и раньше, поэтому равенство str1 == str2 на этот раз не выполнилось. Теперь рассмотрим код, где для конкатенации используется StringBuffer . Его использование гарантирует то, что строка находится не в строковом пуле, а в \"нормальной\" области памяти. import java.io.BufferedReader ; import java.io.IOException ; import java.io.InputStreamReader ; public class StringConcatenationExample { public static void main ( String [] args ) throws IOException { String str1 = \"abc\" ; BufferedReader bufferRead = new BufferedReader ( new InputStreamReader ( System . in )); System . out . print ( \"Type in a string :\" ); String str2 = bufferRead . readLine (); System . out . println ( \"str1 :\" + str1 + \", str2 :\" + str2 ); System . out . println ( str1 == str2 ); } } Результатом выполнения этого кода будет следующий вывод: Type in a string :abc str1 :abc, str2 :abc false Таким образом, в результате тестирования вышележащих сниппетов можно заключить, что строковые переменные будут ссылаться на один и тот же строковый объект только в том случае, если эти объекты были инициализированы одинаковыми значениями. 2. Ручное помещение строки в пул Как мы заметили, строковый пул не всегда используется автоматически. Но что же делать, если его использование может существенно уменьшить количество используемой памяти? Пусть мы создаем класс, описывающий адрес человека. Как известно, более 10 миллионов человек сегодня проживает в Москве. Представляете, как много места может занять использование отдельного объекта-строки для каждого из жителей Москвы? Для того, чтобы вручную поместить строку в пул, необходимо использовать метод String.intern() . Рассмотрим пример: String s1 = \"abc\" ; String s2 = \"abc\" ; String s3 = new String ( \"abc\" ) ; System.out.println ( s1 == s2 ) ; System.out.println ( s1 == s3 ) ; s3 = s3.intern () ; System.out.println ( s1 == s3 ) ; Результат выполнения этого кода будет представлять из себя следующий набор строк: true false true То есть вызов этого метода равносилен созданию строки, для которой значение введено заново с использованием литер. Но будьте аккуратны. До Java 7 в памяти существовала отдельная область PermGen , в которой и располагался пул, которому было отведено ограниченное количество памяти. Начиная с Java 7 , строковый пул помещается в той же области кучи, что и все остальные объекты, что делает строки доступными для сборщика мусора. Указать объем отводимой под строки памяти (которые хранятся в виде хэш-мапа) можно с использованием опции XX:StringTableSize . Так Вы, фактически, создаете свой собственный пул строк, но впрочем, не забивайте голову. ©javacodegeeks","tags":"java","title":"Строковый пул Java"},{"url":"https://stonedastronaut.github.io/lvm-on-luks-na-primere-arch.html","text":"Создаём разделы физические Вот такая структура диска. /dev/sda1 -> /boot /dev/sda2 -> LVM Шифруем раздел LVM cryptsetup luksFormat -c aes-xts-plain64 -s 512 /dev/sda2 больше о параметрах шифрования см. здесь cryptsetup open --type luks /dev/sda2 lvm Создаём разделы на LVM создаём физический раздел LVM: pvcreate /dev/mapper/lvm создаём группу разделов LVM: vgcreate MyStorage /dev/mapper/lvm создаём логические разделы LVM: lvcreate -L 8G MyStorage -n swapvol lvcreate -L 15G MyStorage -n rootvol lvcreate -l +100%FREE MyStorage -n homevol форматируем разделы: mkfs.ext4 /dev/mapper/MyStorage-rootvol mkfs.ext4 /dev/mapper/MyStorage-homevol mkswap /dev/mapper/MyStorage-swapvol наконец-то монтируем mount /dev/MyStorage/rootvol /mnt mkdir /mnt/home mount /dev/MyStorage/homevol /mnt/home swapon /dev/MyStorage/swapvol подготавливаем boot mkfs.ext2 /dev/sda1 mkdir /mnt/boot mount /dev/sda1 /mnt/boot Дальше идёт обычная установка системы, до момента генерации initramfs . Для того, что бы можно было загружаться с lvm надо добавить в /etc/mkinitcpio.conf : /etc/mkinitcpio.conf: HOOKS = \"... encrypt lvm2 resume ... filesystems ...\" encrypted , lvm2 и resume должны стоять перед filesystems конфигурация загрузчика Перед генерацией конфига grub , необходимо добавить информацию о зашифрованных разделах в /etc/default/grub : ... GRUB_CMDLINE_LINUX_DEFAULT = \"quiet resume=/dev/MyStorage/swapvol\" GRUB_CMDLINE_LINUX = \"cryptdevice=/dev/sda2:MyStorage \\ root=/dev/mapper/MyStorage-rootvol\" ... Собственно всё. ссылка на оригинал","tags":"linux","title":"LVM on LUKS на примере arch"},{"url":"https://stonedastronaut.github.io/7-sovetov-dlia-professionalnogo-rosta-programmista.html","text":"1. Регулярная практика программирования Постоянно программируйте, если Вы действительно хотите стать профессионалом мастером своего дела. Вы будете писать ужасные программы, но сможете подняться на новую ступень уже тогда, когда поймете, что они ужасны. Вы начнете писать по-другому, сделав выводы и переосмыслив ошибки. Вам будет казаться, что теперь Ваш код вполне хорош. Но вскоре снова возникнет понимание того, что он далек от совершенства, что разработанная архитектура громоздка и неповоротлива. И это будет новой ступенью на лестнице Вашего профессионального развития. О типичных ошибках можно и нужно читать книги, статьи в Интернете, но без реальной практики программирования, без проб и ошибок ценность этой информации будет нулевая. 2. Культура программирования Относитесь к коду разрабатываемой программы, как к собственному лицу. Выработайте правила оформления текста и постоянно придерживайтесь их. Не загромождайте текст ненужными функциями, закомментированными блоками старого кода и прочим мусором. Старайтесь постоянно улучшать качество кода, стремитесь сделать его как можно более понятным, лаконичным и концептуальным. 3. Храбрость Если Вам кажется, что от кода \"дурно пахнет\", и Вы знаете, как его улучшить, - немедленно удалите этот код и напишите заново. Да, да - именно удалите. Не надо комментировать старое ненужное барахло, думая, что оно еще когда-нибудь пригодится и сработает. Просто возьмите, удалите и напишите с чистого листа новый качественный код. 4. Вера в свои силы Иногда возникает настолько сложная проблема, что руки опускаются. Просто непонятно, что дальше делать. Не паникуйте, а порадуйтесь возможности решить сложную задачу, обогатив свой опыт. Посмотрите на ситуацию аналитически. Создайте прототип проблемы и постепенно приближайте его к самой проблеме. Например, недавно мы с коллегой мучились, пытаясь скомпилировать огромную старую систему, использующую кучу сторонних компонент на древнем компиляторе. В итоге возникала ошибка линковщика, которая не говорила нам решительно ни о чем. Мы создали новый пустой проект и постепенно стали добавлять туда модули злосчастной программы. Так мы смогли локализовать ошибку. Ну, а когда знаешь, в чем именно проблема, - решить ее становится значительно проще! Верьте в свои силы. Человек умнее машины! 5. Быть в авангарде ИТ развиваются быстро и замедляться не планируют. Можно писать замечательные консольные программы на Паскале, но только вряд ли они найдут благодарных пользователей. Все потому, что средства разработки совершенствуются постоянно. Та область, в которой сегодня Вы пионер, завтра будет использоваться повсеместно. То, что сегодня используется миллионами, завтра станет вчерашним днем, \"legacy\", \"deprecated\". Нужно постоянно держать руку на пульсе, чтобы в один прекрасный день не оказаться за бортом парохода современности. На самом деле следить за технологиями не так уж и сложно. В ИТ, как и везде, все новое – это хорошо забытое старое. Нельзя сказать, что за последние годы в программировании появилось нечто принципиально новое, кардинально отличающееся от всего известного ранее. Все, что человек придумывает, основывается на его предыдущем опыте. Секрет в том, что помимо чьих-то там технологий есть Ваш личный опыт, собственная база знаний и технический склад ума, которые от Вас никуда не денутся. И если Вы обладаете этим бесценным багажом, то оставаться в авангарде информационных технологий оказывается вовсе и не сложно. 6. Английский язык Без этого никуда. Пока все новое в сфере как программирования, так и ИТ в целом идет к нам с Запада. Самая лучшая документация, самые полезные форумы, самые интересные блоги всегда были и будут на английском языке. В ИТ индустрии английский давным-давно завоевал полное господство и перемен не предвидится. Техническую документацию придется читать любому программисту. Впрочем, нет никакой необходимости доводить свой английский до Upper Intermediate. Достаточно знать столько, сколько необходимо для работы. Программист обязан уметь читать по-английски. Говорить и писать не так критично, хотя и крайне желательно, но читать обязан. 7. Книги \"must read\" Есть литература, которая обязательно должна быть прочитана любым уважающим себя программистом. Причем читать ее лучше не один раз, а время от времени возвращаясь к некоторым главам или же перечитывая книгу целиком. Понимание многих вещей приходит только с опытом, которого на момент первого прочтения может не быть. Безусловно, прочтение такой литературы поднимает Вас, как специалиста, на новую ступень. Хороших книг много, но эти просто жемчужина литературы: \"Искусство программирования\" , Дональд Э. Кнут \"Объектно-ориентированный анализ и проектирование\" , Гради Буч \"Совершенный код\" , Стив Макконел \"Мифический человеко-месяц\" , Хилл Чапел, Фредерик Брукс \"Приемы объктно-ориентированного проектирования. Паттерны проектирования\" , Э. Гамма, Р. Хелм, Р. Джонсон, Д. Влиссилес А что читаете Вы ? ©geekbrains","tags":"copy\\paste","title":"7 советов для профессионального роста программиста"},{"url":"https://stonedastronaut.github.io/rolikovye-konki-inline-skates.html","text":"Пост о роликовых коньках. Здесь я опишу какие стили катания существуют, и соответсвенно какие ролики выбрать под понравившийся стиль, если Вы новичёк в этом вопросе. Преамбула: независимо от того кто Вы и что Вы думаете, покупая роликовые коньки Вы должны знать, что покупка роликов это не только пара \"сапог\" с колесами, это еще и комплект защиты включая шлем. Данное требования вывел лично на собственном опыте. Лушче быть в броне, дико упасть, подняться и дальше чудить, чем валяться в больнице, просрав сезон катания, и кучу денег/времени на лечение. Минимальный рекомендуемый комплект брони: каска наколенники запястья Вопрос с влиянием погоды на катание. Безусловно мокрая дорога может стать причиной падения, сила трения между асфальтом/бетоном и колесами уменьшается => что вероятность подскользнуться растёт. Но если колеса твёрдые, и не гнать 30-40 км в час, то можно вполне скопойно рассекать по лужам. Но я не рекомендую :-) Температурный режим для катания достаточно большой: от -10°C. Но нужен асфальт или бетон. По снегу не пробовал. Основные стили Fitness . Просто катаемся по городу/парку. Вместо ходьбы или пробежки. Не требует каких либо особых навыков. Просто ездим. FSK . Стиль катания, в котором rider ездит по городу, преодалевая любые препятсвия на своём пути, перепрыгивая их, или просто пробегая не проезжаемые участки пути. Эдакий паркур на колёсах. Здесь понадобятся достаточно сильные ноги и пресс, хотя в процессе осовения данного стиля, они сами собой прокачаются. Используются в основном 2 вида торможения: T-stop . Очень простой в исполнении, и самый важный, без уверенного исполнения данного торможения, лучше не выезжать на улицу. Parallel slide . Один из самых трудных, но самый быстрый вариант торможения. С уверенным исполнением данного слайда, можно разгонятся до скорости света, и ничего не боятся. Также учимся прыгать в длину и высоту. Для катания в этом стиле нам нужны уже хорошие ролики, с крепкой рамой и хорошими жесткими колесами, диаметром 80 мм. Именно этот стиль мне больше всех нравится. Вот пара ссылок на видео с Greg Mirzoyan, наверное лучший FSK rider: Greg Mirzoyan - London 2011 6 years with Greg Mirzoyan Agressive . Думаю название говорит само за себя. Это те самые ребята на рампах, ямах, и скользящие по перилкам. Дико травмоопасный стиль.Многие райдеры в этом стиле не признают защиту, якобы она мешает выполнять трюки, но при этом разбиваются частенько в кровь, и переломы. В этом стиле используются специальные ролики, которые слабо фиксируют голеностопный сустав, и на которых стоит специальная рама для возможности скользить по перилкам, парапетам и пр. выступам. Носим с собой парафин, иначе особо не поскользим. Ссыль на поглазеть THE 2015 XSJADO TEAM Slalom . Это когда катают вокруг конусов. Берем ролики для FSK, ставим на них колёса 76-80-80-76 (мм, для маневренности), конусы, едем в ближайший парк, или пустую парковку, и кружим вокруг конусов. Удовольствие сомнительное, на мой вгляд, но очень многим такой стиль нравится. Ссыль на поглазеть PSWC 2012' Paris Slalom World Cup PowerBlade . Не знаю как сильно он распространён, но когда я его увидел, то мне он сразу понравился. Это симбиоз FSK и Agressive , т.е. к харакетрным трюкам FSK добавляем скольжение по всяким выступам и получаем сабж. Ссыль на поглазеть PowerBlade the Waterway SpeedSkate . Этот стиль для любителей скорости. Особенность здесь заключается в роликах. Сам ботинок выглядит как футбольная бутса, а колеса ставятся большого диаметра, от 100 мм. Ссыль на поглазеть Pamplona - Puente la Reina 2014 Inline Speed Skating International Marathon Выбор роликов Существует несколько самых распространненых производителей роликовых коньков. Настоятельно рекомендовать какой-то опрелённый не буду, потому как будущие свои ролики нужно обязательно мерить. И т.к. ноги у каждого разные Вам может подойти, то что мне не подойдет. Fitness . Да тут и выбирать собственно долго нет смысла. Подойдут любые. Главное на них потом, не начать осваивать FSK или Slalom, иначе кончится может травмами. Если твёрдо уверены, что трюкачить - это не Ваше, то можете брать любые ролики. Но я рекомендую выбирать из списка для FSK. Производители роликов для FSK, также выпускают ролики и для Fitness и др. стилей. FSK . Здесь могу выделить 3 основных производителя, и еще пару других: Seba PowerSlide Rollerblade Fila K2 Seba, PowerSlide и RollerBlade - лидеры в производстве роликовых коньков в принципе, и в частности для FSK. Из Seba порекомендую модели FR1 или High. Из моделей Rollerblade - Fusion или Twister. В моделях PowerSlide, увы, не разбираюсь. Fila - та же Seba, только сбоку, да и были скандалы, что Fila тупо копирует Seba при этом продает за такие же деньги. Хотя кому-то Fila пришлась по душе больше, чем Seba. K2 - в основном делает ролики для агрессивщиков, моделей для FSK у них не много. Agressive . USD Xsjado Razors Seba Remz тысячи их... Могу выделить из них Xsjado за их дизайн. Они выполнены очень удобно, скелет ботинка в который мы вставляем ногу, в своей обуви. И крепления сделаны удобно, что надевать и снимать ролики достаточно быстро. В общем идеал если часто надеваем, снимаем ролики. И купите Вашему любимцу рюкзак. Лично мне нравится USD рюкзак. Защита Каска - производители всё те же, что и раньше, но лично у меня TSG. Выбираем понравившийся, меряем, покупаем и наша голова в поряде. По массе выбираем в районе 300 - 450 граммов, меньше будет сдувать ветром, а больше - просто тяжело. Бронь - производители опять таки, всё те же. Но от себя могу сказать, что у Seba годная защита на запястья, а у USD удобная и прочная защита (USD делает для агрессивщиков, а здесь и уровень защиты высокий и всё очень эластично выполено. Комфорт Рекомендую приобрести носки для роликов, иначе в обычных могут возникнуть проблемы с мазолями и т.д. Из всех что довелось использовать мне и моим знакомым, самые годные носки у seba. Они потому что не просто носки, а нано-носки :-) PS: Роллер-спорт достаточно экстремальный и, в зависимости от вида катания, травмоопасный. Но если Вы дружите с головой, купите защиту, и будете выполнять трюки осознавая свои силы, то травм можно избежать вовсе. Но у него есть и неоспоримые плюсы. Тренируется практически всё тело. Некоторые качки, даже сушатся именно на роликах. Человек на роликах попадает, какбы в другое измерение, он вроде уже не пешеход, но еще и не велосипедист. Хотя последних по скорости может смело уделать, даже на 80-х колёсах. пара фоток:","tags":"unsort","title":"Роликовые коньки (inline skates)"},{"url":"https://stonedastronaut.github.io/katok-nikogo-ne-zhdiot.html","text":"Из всего, что я делаю или использую сегодня, единственное, что у меня осталось общего с моей первой работой — это написание кода. Все остальное менялось и изменялось, и изменялось снова. Если вы все время не продолжаете учиться, читать, совершенствовать свои навыки, то, в конечном счете, этот мерзкий каток позади раздавит вас окончательно. И тут ваша карьера, скорее всего, закончена. Когда я устроился на мою первую работу, я и понятия не имел, что будет дальше. В 1981 году ничего не предвещало, что все будет меняться гигантскими темпами. Люди все еще писали пакетные приложения на мэйнфреймах, везде были мини-ЭВМ с терминалами и персональные компьютеры были немногим больше, чем игрушками. Мало кто имел компьютер у себя дома, не было никакой электронной почты за пределами крупных компаний и даже это практически не использовалось. И, конечно, не было никакого Интернета. Было лишь несколько языков программирования и большинство из них были созданы в 1950 году. Было несколько журналов, которые писали о программировании и не было ничего, даже отдаленно напоминающего выставки. У меня даже были друзья, которые получили степень CS(Computer Science) и которые даже не касались ничего из того, что недавно было разработано. Люди могли получить работу программиста даже без опыта или образования, также как и я. Вы либо учились этому самостоятельно, либо, может быть, на работе. В мой первый день я почти совсем не представлял, что за всем этим стоял громыхающий монстр, который только начинал свой разбег. Мои первые два года состояли, в основном, в программировании на Fortran с небольшими вставками ассемблера. Я продолжал работать с Basic и различными диалектами ассемблера, и даже баловался с Pascal дома. Я читал все, что можно было найти, только потому, что это было интересно. Когда я попал в группу, занимавшуюся микрокомпьютерами, темп жизни неожиданно начал ускоряться. После моих усилий в написании \"яблочного\" приложения\", появился IBM PC и я должен был писать для него в Pascal. Меня попросили проверить комплект портативных Unix-боксов, которые должны были быть направлены потенциальным клиентам для проверки спецификаций F-16. Это было мое первое знакомство с C, которое и привело меня к заказу компилятора C на работу. Никто на работе не слышал о нем. В то же время я кратко ознакомился с Lisa, но при этом, понятия не имел об Object Pascal. Я видел рекламу Mac, но у нас не было ни одного, хотя я бы хотел поработать с одним из них. Когда я уволился и начал свой стартап(когда-нибудь я об этом расскажу) по созданию программы для электронных таблиц для Mac(Trapeze), мы решили сделать ее на С, хотя Apple, на тот момент, все еще предпочитали Pascal. В последующем, С оказался верным выбором, так как C господствовал в течение длительного времени (и до сих пор является основным для Linux). Примерно в то же время я прочитал знаменитый номер журнала Byte о Smalltalk и сразу же понял, что за объектами будущее, и что мне нужно немедленно разобраться в них. Сейчас я действительно начал понимать, что темпы изменений в программировании никогда уже не замедлятся снова. Даже во время конца 80-х, без интернета или электронной почты, скорость с которой появлялось что-то новое вырисовывалась все более явно. После продажи стартапа и начала консультаций по программированию на Mac, со временем мы начали DeltaGraph (это уже другая история), и я создал несколько расширений С для работы с объектами. C++ все еще не существовало, по крайней мере, юзабельного, но я хотел использовать его преимущества, поэтому я написал несколько банальных расширений, которые позволили мне собрать несколько драйверов вывода, но по-прежнему оставить только один внутренний генератор выхода. Наконец, в начале 90-х появился C++ и я уже понимал, как проектировать с применением ОО. Конечно, я по-прежнему время от времени кодил на С. В какой-то момент я прочитал о так называемом \"web\" и немного поработал с текстовым браузером и задумался над тем, куда все это приведет. В конечном итоге, я работал в Bay Area около года в середине 90-х и помню тот день, когда Netscape вышла в мир. Но даже видя это, в тот момент я совсем не понимал, какие огромные изменения должны были произойти. Мысленно возвращаясь в то время, я помню, как читал о новом языке Java и изучал его. К тому времени Интернет уже начал развиваться, он был все еще так примитивен и я не был уверен, куда все это шло, но теперь я знал достаточно, чтобы участвовать. Когда начинаются значительные изменения в мире, вы можете не знать, что будет в дальнейшем, но вы уже должны шагать в ногу с ними. Я устроился на работу в веб-консалтинговую фирму, которая специализировалась на NeXT WebObjects которые были разработана в некоем извращенном языке, называемом Objective-C. Очевидно, некоторые люди в начале 80-х как и я были очарованы C и Smalltalk, за одним исключением — они сделали настоящий язык из него. Я не только изучил этот новый язык, но нашел другой странный язык — Javascript, который имел мало общего с Java. Добавьте к этому HTML и внезапно у меня появилась совершенно новая платформа для работы. Примерно в это же время я начал встречаться с людьми, которые тоже рассказывали о других языках программирования. Оглядываясь на времена моей первой работы, я понял, что больше я не смогу знать обо всем, что происходит в программировании. Я должен был научиться сосредотачиваться на определенных моментах, и достаточно уделять внимания другим, чтобы ничего не упустить. Большой каток начал свое движение. Во время этой первой волны веб-программирования некоторые из моих друзей, которые получили CS степень, когда я только начал работать, внезапно оказались безработными, поскольку люди начали отказываться от мейнфреймов и Cobol, а они ничему не научились за прошедшее время. В отличие от меня, они были сосредоточены только на том, что они узнали и с чем работали на протяжении почти двух десятилетий, и все это вдруг исчезло. Они были раздавлены. Когда только появился Java и J2EE (ныне JEE) сначала я просто попробовал поработать с ним, а в конечном результате начал демонстрировать его остальным. Я назвал его «Чуждая Технология». Довольно скоро мы перешли на создании веб-приложений с использованием Java J2EE, именно тем примитивным, каким он был тогда. Работая в середине 00-х, я прочитал о так называемом AJAX и решил использовать его в паре внутренних приложений, которые я проектировал. Когда я упомянул об этом в команде проектировщиков, они обвинили меня в применении новых технологий! Мне пришлось объяснить, что это был простой Javascript. Они сказали мне, что Javascript умирает, что незачем тратить время на попытки сделать что-то новое с ним. А люди смешные. Теперь, когда интернет работает на всю катушку и понятие открытого исходного кода стало общеупотребительным, разверзся настоящий ад. Я даже близко не успевал за развитием всего этого. Теперь нужно было выбирать то, в чем вы будете хороши, что-то для интереса и развития и надеяться, что вы по крайней мере знаете названия всего остального. Вся эта ситуация усугубляется и по сей день, и, вообще-то, иногда даже пугает. Каждую неделю появляется еще один новый язык. Добавьте к этому все фреймворки. HTML5, CSS3 и еще больше сокращений, которые никто не сможет вспомнить все разом. Сегодня программирование является огромным водоворотом новых идей. Некоторые из них поразительны, некоторые имеют огромный потенциал, многие оканчиваются ничем. Но во всем этом море программирования вы должны выбрать правильное направление! Этот долбанный каток сейчас ускоряется и программисты работают как сумасшедшие, чтобы успевать впереди него. Мне нужно заниматься ROR или писать только приложения на JavaScript? Должен ли я учить Python или Scala? SQL или NоSQL? IOS или Android? Облака или нет? Безумный или сумасшедший, выбери свой яд сам. Вспоминая три десятилетия работы в режиме успевать-впереди-катка, я не могу поверить, как много изменилось с того момента, когда я писал Fortran на бумаге, потому что у нас было 7 человек за одним терминалом. За это время произошло много изменений, и многие люди вынуждены были стать менеджерами или заняться сетями или продавать гамбургеры. Что будет в ближайшие 30 лет, как быть? Останутся ли программисты или мы все будем раздавлены? Я не могу вспомнить ни один период в истории, когда так много менялось с такой огромной скоростью в одной отрасли. Уже нет времени передохнуть, не изучая что-то новое на тот случай, если то, что вы знаете сегодня, завтра уже устареет. Не имеет значения, 20 лет вам или 55, знаете вы что-то или совсем ничего, то, что вы сделаете сегодня, уже не будет актуально через 10-20 лет. Я наблюдал за этим раз за разом. Одним из моих любимых выражений является «Единственная вещь, которая никогда не меняется, так это возможность изменить себя». Только я думаю, что можно добавить кое-что — изменения продолжают ускоряться. И скрежещущий монстр дышит вам в затылок и топливо у него не кончается. © habrahabr","tags":"copy\\paste","title":"Каток никого не ждёт"},{"url":"https://stonedastronaut.github.io/dzhon-rezig-pishite-kod-kazhdyi-den.html","text":"Прошлой осенью работа над моими побочными проектами зашла в тупик: я практически не продвигался вперёд и у меня никак не получалось делать больше, не принося в жертву свою основную работу. В моей организации работы обнаружилось несколько серьёзных проблем. В основном я работал по выходным и иногда по вечерам. Как оказалось, это не самая лучшая для меня стратегия. Необходимость сделать за выходные как можно больше и лучше сильно давила на меня, а если мне не удавалось доделать задуманное, это ощущалось как провал. Проблему усугубляло и то, что не было никакой гарантии, что очередные выходные будут свободны, и даже если так — не факт, что я захочу кодить с утра до вечера все эти два дня — надо ведь иногда как-то развлечься или просто расслабиться. Кроме того, недельный перерыв — это слишком много, очень легко забыть, над чем ты работал и на чём остановился, даже если делать заметки. А уж если в выходные поработать не удавалось — то перерыв растягивался на две недели. Такие многонедельные переключения контекста могут быть смертельными — многие мои проекты погибли, не родившись, от такого недостатка внимания. Услышав о невероятном эксперименте Дженнифер Девальт, которая решила изучить программирование, создав 180 сайтов за 180 дней, я отважился испробовать сходную тактику: работать над побочными проектами каждый день. Я установил для себя несколько правил: Я обязан кодить каждый день. Я могу заниматься другими вещами — писать документацию или статьи в блог, но только в дополнение к работе над кодом. Это должен быть функциональный код. Возня с отступами, переформатирование, и, насколько это возможно, рефакторинг — не считаются. Я могу заниматься всем этим, но это не может быть основной частью дневной нормы. Считается только код, написанный до полуночи. Весь код должен быть открытым и публиковаться на Гитхабе. Некоторые из этих правил кажутся надуманными. Технически, нет никакой нужды писать код исключительно до полуночи, но я хотел заставить себя не засиживаться допоздна, чтобы код не был грязным. Также не обязательно публиковать всё написанное на Гитхабе. Мне это правило было нужно, чтобы внимательней относиться к коду — как можно раньше задумываться о повторном использовании или модульности. Эта тактика оказалась очень эффективной, и сейчас приближается уже двадцатая неделя непрерывной работы. Я захотел написать об этом, так как это полностью изменило мой стиль работы и сильно повлияло на мою жизнь и душевное состояние. Эти изменения в рабочих привычках принесли множество интересных результатов: Минимальный рабочий код. Мне пришлось выделять для работы над кодом не меньше получаса в день. Очень трудно написать что-то осмысленное за меньшее время, особенно учитывая, что приходится вспоминать, на чём остановился вчера. Иногда мне удавалось поработать чуть больше (но обычно не больше часа), а по выходным бывало, что и весь день. Программирование как привычка Думаю, что это самый важный итог моего эксперимента: главное, чтобы вы хотели что-то изменить для себя, а не произвести своей работой внешнее впечатление на кого-то другого. То же самое верно и для любой диеты или физических упражнений: вам никогда не добиться успеха, если вы делаете их не для себя самого. Победа над тревогой До начала своего эксперимента я часто чувствовал сильное беспокойство от того, что не успел сделать «достаточно» работы, или продвинуться «достаточно» далеко (хотя измерить эту «достаточность» я не мог, так как у побочных проектов не было конкретных дедлайнов). Я понял, что ощущуение прогресса в работе настолько же важно как и сам прогресс. У меня открылись глаза! Как только я начал стабильно продвигаться вперёд каждый день, вся моя тревога постепенно растаяла. Я был удовлетворён объёмом сделанной работы и больше не испытывал одержимости сделать как можно больше в один присест. Выходные Работа по выходным раньше была ключевым способом добиться заметного прогресса в побочных проектах, так как это было единственное время, когда я успевал как следует продвинуться. Теперь выходные уже не так важны — и это очень хорошо. Планы и ожидания, копившиеся целую неделю, чаще всего приводили только к разочарованиям. Мне редко удавалось сделать всё, что я задумал, и это заставляло меня в следующие выходные отказаться от развлечений — сходить в кафе или в музей, погулять в парке или провести время с девушкой. Как бы ни были важны для вас побочные проекты, они не должны занимать всю жизнь. Фоновая обработка Интересный побочный эффект от регулярной ежедневной работы над проектом заключается в том, что ваш разум начинает работать над ним и в фоновом режиме. Очень часто, когда я просто иду по улице, или принимаю душ, или занимаюсь чем-то ещё, что не требует умственных усилий, я думаю над тем, что мне предстоит сделать, и часто нахожу решение текущих проблем. Такого не было, когда я программировал лишь раз в неделю. В течение недели голова была занята другими задачами, или вообще беспокойством по поводу того, что я никак не успеваю поработать над побочным проектом. Переключение контекста Каждый раз, возобновляя работу над побочным проектом, приходится тратить время на переключение контекста. К сожалению, после недельного перерыва это переключение идёт с большим трудом. Ежедневная работа в этом смысле гораздо эффективнее, так как перерывы гораздо меньше, и восстановить контекст можно гораздо быстрее. Управление временем Один из самых важных для меня аспектов эксперимента — я научился лучше распределять время между работой, побочными проектами и остальной жизнью. Зная, что мне придётся сделать хоть немного ежедневно, я просто обязан был научиться лучше планировать свой день. Если у меня были другие планы на вечер, мне приходилось переносить работу над проектом на более раннее время, до начала основной работы. Если я не успел поработать, но задерживался где-то, мне приходилось вернуться домой пораньше, чтобы успеть закончить, вместо того, чтобы просто пропустить день. Признаюсь, у меня стало оставаться меньше времени на хобби (гравюры укиё-э и другое), но тут уж ничего не поделаешь, приходится выбирать. Внешнее восприятие Ещё один плюс появляется, когда твои близкие привыкают к твоим новым правилам. Моя девушка понимает, что я должен хоть немного поработать над проектами каждый день, и другие дела иногда приходится планировать с учётом этого. Очень приятно, когда ты можешь сказать «Да, мы можем пойти прогуляться (сходить в кино и т.п.) но после этого мне надо закончить работу» — и знать, что к этому отнесутся с пониманием. Сколько кода я написал? Мне с трудом верится в то, насколько много я успел написать за последние несколько месяцев. Я сделал пару сайтов, переписал несколько фреймворков и написал кучу новых модулей для Node. Я сделал настолько много, что иногда даже не помню всё, что я написал — то, что было всего несколько недель назад, кажется далёким прошлым. Я чрезвычайно удовлетворён объёмом проделанной работы. Я считаю, что мой эксперимент прошёл с огромным успехом и хочу придерживаться новых привычек настолько долго, насколько смогу. Я настоятельно рекомендую эту тактику всем, кто хочет как следует продвинуться в своих побочных проектах. Если попробуете, дайте мне знать, сработало это для вас или нет — мне очень интересно услышать как можно больше реальных историй. ©habrahabr","tags":"copy\\paste","title":"Джон Резиг - Пишите код каждый день"},{"url":"https://stonedastronaut.github.io/kak-podderzhivat-motivatsiiu-dlia-zaniatii-programmirovaniem.html","text":"Залог успеха в программировании - это регулярные занятия. Мы собрали самые полезные советы о том, как побороть прокрастинацию и мотивировать себя в обучении. Но, недостаток мотивации часто приводит к тому, что находятся более \"важные\" дела, а программированию уделяется всё меньше времени. Многие новички забрасывают занятия, так и не получив ощутимых результатов. Мы собрали самые полезные советы пользователей Quora, среди которых много практикующих программистов, о том, как побороть прокрастинацию и мотивировать себя в обучении: —Nathan Burchfield, IT Administrator and Developer Окружите себя контентом, связанным с программированием. Подпишитесь на тематические блоги и Twitter. Поделитесь своими идеями с близкими друзьями или семьей. Иногда, когда вы получаете положительные отзывы от других, это мотивирует настолько, что потом сложно оторваться от экрана компьютера. Программируйте не отвлекаясь в течение 2-х минут. Скорее всего, произойдет эффект снежного кома и вы продолжите кодить. Покажите свой код другим. Если вы знаете, что люди могут его видеть, то, как правило, будете держать его актуальным и чистым. Я поставил на заставку рабочего стола такую картинку. Это первое, что я вижу, когда сажусь за компьютер, отлично помогает направить свою деятельность в нужное русло: —Juan Gallardo, Ruby programmer Хитрость заключается в том, чтобы найти проекты, которые мотивируют. И не имеет никакого значения, что это будет. Кошачий блог, социальная сеть для мопсов и т.д. Просто найдите то, что вас увлекает или заставляет смеяться и работайте над этим. Например, я сделал Myspace для кошек. —Nikith Shetty Посмотрите какую-то научную фантастику или фильм про секретных агентов наподобие \"Миссия невыполнима\", где видно, на что способны хакеры. Или \"Социальную сеть\" и вдохновитесь тем, как Марк Цукерберг за одну ночь укладывает сервера Гарварда. —M.Santhosh Kumar По моему опыту, новички начинают программировать по двум причинам: обучение развлечение В первом варианте они часто сдаются из-за скуки и путаницы. Те же, кто начинает знакомство с программированием в качестве развлечения, чаще всего углубляются и начинают уделять ему всё больше времени. Они-то на самом деле начинают учиться. Программирование проще всего изучать тогда, когда вы делаете это в последнюю очередь. Учитесь играючи. —Laveena Bachani, CS graduate Программирование, как видеоигра. Нужно несколько шагов, чтобы разобраться в правилах. Когда концепция понятна, то пробуешь выиграть, но это редко получается с первого раза. Это вызов. Это заставляет играть до победного конца. Медленно, но верно вы подбираетесь к секретной формуле успеха, разбираетесь в тактике и овладеваете ей в совершенстве. То же самое с программированием. Нужно побеждать. Вы отлаживаете код, но он опять выдает ошибку, опять отлаживаете, опять ошибки. Но в определенный момент вы находите решение! —Abir Bhattacharyya, Software Engineer and Statistical Data Analyst Я бы всё время валялся на диване, ел мороженое, пиццу и леденцы. Почему я, всё таки, выбираю программирование? Потому что, занимаясь им, я могу заслужить любовь, заработать деньги, наслаждаться созданием крутых вещей, радоваться тому, что люди используют мои крутые вещи… и обеспечить своим кошкам счастливую жизнь. —Raghav Yadav Любопытство - это ключ. Думаю, что будущее за программированием. Не могу представить мир без него. Я часто пишу код большую часть рабочего дня и потом программирую в свободное время для себя. Это моя мотивация. Один из примеров - я написал приложение для настройки субтитров во время просмотра фильма на тот случай, если они не соответствуют звуковому ряду. Похожие небольшие утилиты помогают решать надоедливые проблемы. Программирование это прекрасно! —Puneet Khanduri, Platform Engineer at Twitter Программирование - это возможность воплотить идеи в реальность. Это самая сильная мотивация для большинства программистов. —Christopher Reiss Закройте социальные сети. Никаких \"я только проверю сообщения\". Тусуйтесь с теми, кто тоже кодит. Такое общение - это отличный способ оставаться \"в теме\", будь это профессиональный юмор или обсуждение серьезных вопросов. Помогает музыка. Что-нибудь атмосферное, чтобы не отвлекало, а, наоборот, настраивало на нужный лад. Если совсем трудно сконцентрироваться, возможно, нужно посоветоваться с врачом на предмет синдрома дефицита внимания. Некоторым очень умным людям отлично помогли препараты, улучшающие концентрацию. Спросите себя: программирование - это мое? Мне действительно это нравится? Если нужно каждый раз прилагать геркулесово усилие, чтобы заниматься им, то, возможно, это не ваше. Это нормально, большая ошибка насиловать себя, занимаясь тем, что не вызывает особого желания. —Raphael John Скажу только одно: \"Мастерство начинается с небольших шагов\". —Hridesh Kumar Цель стать хорошим программистом должна быть краткосрочной, нужно представлять более масштабную картину того, кем вы хотите видеть себя через 5 лет. —Jaime López, Programmer, Code Designer Меня мотивирует создание собственных видеоигр в качестве развлечения. —Gene Sewell, Programmer, designer, wanderer Мотивация растет тогда, когда вы видите результат своих стараний. Но если вы, на самом деле, не очень заинтересованны в программировании, то не получите отдачи от достигнутого. Важно выбрать такой род деятельности, где результат будет иметь для вас большую ценность. —Yu LongYing, c++ programmer Попробуйте сделать какую-нибудь интересную штуку, которая привлечет внимание вашей девушки/парня. Помните, гордость - это ваша мотивация, а упорство - залог успеха. —Deepankur Singh Честно говоря, меня мотивирует большая зарплата, которая у программистов достаточно высока. —Douglas Walter, Full Stack Developer Когда я чувствую себя инертным, мне нравится переключаться и фокусироваться некоторое время на другом языке. Кроме того, ничто так не заводит, как работа над чем-то своим и тем, во что ты веришь. Резюмируя, можно сделать вывод, что все блестящие достижения в программировании - это результат кропотливой работы шаг за шагом. Возьмите курс на нечто большее, чем обучиться программированию, и день за днем, следуя этому курсу, мотивируйте себя делать небольшие шаги. Вам будет гораздо проще, если слово \"работа\" заменить на \"развлечение\". Сложно назвать работой или учебой то, что всецело захватывает, как любимая игра. Линус Торвальдс, создатель Linux, утверждает: \"большинство хороших программистов делают свою работу не потому, что ожидают оплаты или признания, а потому что получают удовольствие от программирования\". Научитесь получать удовольствие - это лучшая мотивация. ©geekbrains","tags":"copy\\paste","title":"Как поддерживать мотивацию для занятий программированием?"},{"url":"https://stonedastronaut.github.io/remeslo-programmista-zolotye-pravila.html","text":"Данный пост представляет собой выдержку «золотых правил» из примечательной книги Питера Гудлифа «Ремесло программиста» . Глава 1. Держим оборону Не делайте никаких допущений. Не зафиксированные формально допущения часто служат причиной отказов, особенно с ростом объема кода. Чем больше спешки, тем меньше скорость. Всегда думайте, что вы собираетесь ввести с клавиатуры. Не верьте никому. Кто угодно, включая вас самих, может сделать ошибки в логике вашей программы. Ко всем входным и выходным данным относитесь с подозрением, пока не проверите, что они допустимы. Предупреждения компилятора помогают выявить массу глупых ошибок. Всегда включайте их вывод. Держитесь того, чтобы ваш код компилировался молча. Берегите все ограниченные ресурсы. Тщательно организуйте их захват и освобождение. Глава 2. Тонкий расчет Поймите, кто реально станет читать ваш исходный код: другие программисты. Пишите с расчетом на них. Выясните, какие стандарты кода есть для выбранного вами языка, и освойте каждый из них на практике. Оцените преимущества и недостатки каждого. Выберите какой-то один правильный стиль кодирования и придерживайтесь его постоянно. Если в вашей группе принят некий стандарт кодирования, придерживайтесь его. Свой собственный излюбленный стиль оставьте в стороне. Скажи «нет» религиозным войнам. Не вступай в них. Отойди в сторону. Глава 3. Что в имени тебе моем? Учитесь давать объектам прозрачные имена — они должны ясно описывать то, что за ними скрывается. Чтобы придумать хорошее имя, главное — четко понимать, для кого оно предназначено. Только в этом случае имя может стать осмысленным. Если не удается придумать хорошее имя объекту, спросите себя, понятно ли его назначение. Изучите правила образования имен в языке, с которым работаете. Еще важнее изучить идиомы этого языка. Есть стандартные способы формирования имен? Вот ими и пользуйтесь. Ясность имени предпочтительнее его краткости. Следует учитывать относительные достоинства коротких и длинных имен, особенно в зависимости от области действия переменной. Предпочтительней такое правило именования, которое различает имена переменных и имена типов. Давайте функциям имена с внешней точки зрения, в виде фраз, выражающих действия. Описывайте логическую операцию, а не способ реализации. Избегайте в именах лишних слов. В частности, в именах типов — таких слов, как class, data, object и type. Давайте пространствам имен и пакетам имена, логически связанные с содержимым. Макросы в С/С++ всегда выделяют прописными буквами, чтобы сделать хорошо заметными, и тщательно выбирают их имена, чтобы избежать конфликтов. Никогда не выделяйте прописными буквами другие объекты. Выберите единообразную системы именования и последовательно применяйте ее. Степень необходимой детализации имени зависит от контекста его применения. Создавая имена, учитывайте контекстную информацию. Глава 4. Литературоведение Не пишите код, который нуждается во внешней документации. Он ненадежен. Пишите такой код, который понятен без посторонней документации. Пишите код, который может прочесть нормальный человек, причем без напряжения. Компилятор как-нибудь справится. Избегайте волшебных чисел. Пользуйтесь именованными константами. Важный участки кода должны выделяться на общем фоне и быть легко читаемыми. Спрячьте все, что не должно интересовать клиентов. Старайтесь группировать родственную информацию. Делайте эту группировку наглядной с помощью средств языка. Не выводите бессмысленных сообщений об ошибках. В зависимости от контекста представьте наиболее уместную информацию. Помещайте в код комментарии только в том случае, если не удается облегчить его понимание иными способами. Пользуйтесь инструментариями грамотного документирования для автоматической генерации документации по вашему коду. Глава 5. Заметки на полях Учитесь писать ровно столько комментариев, сколько необходимо. Отдайте предпочтение качеству, а не количеству. Не пожалейте труда, чтобы ваш код не требовал поддержки в виде уймы комментариев. Хорошие комментарии объясняют «почему», а не «как». Один источник для каждого факта. Не копируйте код в комментариях. Обнаружив, что вы пишете многословные комментарии, описывающие ваш код, остановитесь и задумайтесь. Не признак ли это того, что существует некая проблема более высокого порядка? Думайте, что пишете в комментариях; не давите бездумно на клавиши. Прочтите комментарий снова в контексте кода. Ту ли информацию он содержит? Комментарии — часть повествования кода. Размещайте их так, чтобы порядок чтения был естественным. Снабжайте каждый файл исходного кода прологом в виде комментария. Комментарии должны касаться настоящего, а не прошлого. Не описывайте того, что претерпело изменения, и не рассказывайте о том, что было раньше. Если вы изменили код, проверьте правильность комментариев, находящихся рядом с ним. Глава 6. Людям свойственно ошибаться Обработка ошибок — дело серьезное. От нее зависит стабильность вашего кода. Не оставляйте сбойную ситуацию без внимания. Если вы не знаете, как справиться с проблемой, сигнализируйте об отказе вызвавшему коду. Не заметайте мусор под ковер в надежде, что все как-нибудь обойдется. Никогда не пренебрегайте поступающими вам сообщениями об ошибках. Если существует канал для сообщений об ошибках, значит, для этого есть причины. Обрабатывайте все ошибки в наиболее благоприятном контексте, когда становится ясно, как корректно с ней справиться. Игнорирование ошибок не экономит вашего времени. Вы потратите больше времени на выяснение причин некорректного поведения программы, чем вам понадобилось бы для написания обработчика ошибок. Если вы пишете код, который может отказать, одновременно с ним пишите код для обнаружения и обработки ошибок. Не откладывайте это на будущее. Если вы все же вынуждены отложить обработку, по крайней мере, напишите оснастку для обнаружения ошибок. Глава 7. Инструментарий программиста Изучите свои стандартные инструменты вдоль и поперек. Время, которое вы потратите на их изучение, незамедлительно окупится. Относитесь к инструментам программирования прагматически; пользуйтесь ими, только если они облегчают вашу жизнь. Узнайте, какие виды инструментов существуют. Выясните, где их можно взять, даже если в данный момент они вам не нужны. Для каждой задачи есть свой инструмент. Не стоит щелкать орехи кувалдой. Следите за выпуском новейших версий своего инструмента, но проявляйте осторожность при обновлении. Выбор редактора кода имеет решающее значение; он оказывает огромное влияние на то, как вы будете писать код. Выучите несколько языков. В каждом вы обнаружите особый способ решения задач. Рассматривайте их как набор инструментов и выбирайте тот, который наиболее эффективен в конкретной ситуации. Глава 8. Время испытаний Тестирование может вскрыть только наличие ошибок. Оно не может доказать отсутствие неисправностей. Не поддавайтесь ложному чувству спокойствия, если код прошел ряд неадекватных тестов. Тестируйте каждый написанный вами фрагмент кода. Не рассчитывайте, что кто-то другой сделает это за вас. Чтобы сделать тестирование эффективным, его нужно начинать заранее, когда выявляемые ошибки еще не могут принести большого вреда. Тестовый код можно писать раньше, чем рабочий! Пишите тесты для всех выявленных ошибок. Прогоняйте свои тесты как можно чаще. Читая код, очень легко обмануться и поверить, что он работает правильно. Если вы написали код, то при его чтении вы будете видеть то, чтособирались написать, а не то, что написали на самом деле. Учитесь читать код с циничным недоверием. Напишите полный набор тестов, каждый из которых будет проверять определенный аспект кода. Пятнадцать тестов, которые демонстрируют одну и ту же ошибку, менее полезны, чем 15 тестов, демонстрирующих 15 разных ошибок. Архитектура кода должна облегчать его тестирование. Насколько это возможно, автоматизируйте тестирование кода. Это быстрее и проще, чем выполнять тесты вручную, и гораздо надежнее: более вероятно, что тесты станут выполняться регулярно. Выполняйте тестирование автоматически в ходе процедуры сборки. Глава 9. Поиск ошибок Компилируйте код при включенном выводе компилятором всех предупредительных сообщений. Тем самым вы обнаружите потенциальные проблемы раньше, чем столкнетесь с ними реально. Следуйте золотому правилу отладки: думать головой. Установите разумное временное ограничение на «бессистемную» отладку, и если она окажется безуспешной, переходите на более методичный способ. Изучите отлаживаемый код — трудно найти ошибки в коде, который вам непонятен. Когда вы ищете ошибку, неверьте никому. Проверьте самые невероятные причины, вместо того чтобы сходу отвергнуть их. Не принимайте ничего на веру. Если сборка продукта не прошла, смотрите на первую ошибку компилятора. Последующие сообщения заслуживают гораздо меньше доверия. Отладка — это методичная работа, медленно сужающая кольцо вокруг места нахождения ошибки. Не следует относиться к ней как к игре в укадайку. Первый шаг на пути установления места ошибки — это определение способа ее уверенного воспроизведения. Начните с известного места, например, с точки аварийного завершения программы. Затем двигайтесь в обратном направлении в сторону причины, вызвавшей сбой. Если вам показалось, что вы нашли причину ошибки, досконально исследуйте ее и убедитесь, что не ошиблись. Не принимайте безрассудно первую же гипотезу. Отладка заканчивается лишь тогда, когда вы докажете, что ошибка устранена и проблема решена навсегда. Проявляйте крайнюю осторожность при исправлении ошибок. Следите, чтобы ваша модификация не покалечила ничего остального. Исправляя ошибку, проверьте, не повторяется ли она в близких разделах кода. Уничтожьте ошибку раз и навсегда: исправьте все ее дубликаты немедленно. Из каждой исправленной ошибки делайте выводы. Можно ли было ее избежать? Можно ли было обнаружить ее быстрее? Столкнувшись с поведением, которое вы не можете объяснить, умеренно пользуйтесь отладчиками. Не привыкайте к тому, чтобы сразу бросаться на них, не попытавшись сначала понять, как работает ваш код. Глава 10. Код, который построил Джек Считайте систему сборки частью дерева исходного кода и ведите их совместно. Они тесно связаны между собой. Все программисты, участвующие в проекте, должны пользоваться единой системой сборки. Иначе все они будут собираться разные программные пакеты. Правильная система сборки позволяет многократно создавать физически идентичные бинарные файлы. Вы должны быть в состоянии достать дерево исходные кодов трехлетней давности и правильно собрать его заново. Правильная система выглядит как одна операция. Достаточно нажать кнопку или выполнить одну команду. Для каждого правила сборки напишите соответствующее правило чистки, которое отменяет всю операцию. Организуйте автоматическую процедуру сборки своего программного продукта. Проверяйте с ее помощью работоспособность вашего кода. Финальные сборки всегда выполняются из чистого исходного кода. Позаботьтесь, чтобы потом всегда можно было получить этот чистый исходный код из архива или системы управления версиями. Проводите тестирование финальной конфигурации своего приложения, а не только рабочих сборок.Небольшие различия между ними могут отрицательно сказаться на поведении кода. © habrahabr Продолжения: здесь","tags":"copy\\paste","title":"Ремесло программиста. Золотые правила"},{"url":"https://stonedastronaut.github.io/52-voprosa-kotorye-vy-dolzhny-zadat-na-sobesedovanii.html","text":"Вы, наверное, уже знаете, что интервью — это не просто очередной этап при устройстве на работу, это также ваша возможность разобраться, подходит ли вам эта работа. Для этого важно задать некоторые вопросы. Что вы хотите знать об этой должности? О компании? О подразделении? О команде? О корпоративной культуре? Задавать вопросы бывает сложно. Мы это знаем. Для того, чтобы упростить вам это задание, мы приводим список ключевых вопросов для интервью. Мы определённо не рекомендуем задавать их все. Пожалейте рекрутера! Когда в конце интервью или его части вас спрашивают: «Итак, есть ли у вас к нам вопросы?», то обязательно воспользуйтесь данным списком (попробуйте восстановить в памяти), чтобы убедиться, что вы охватили все интересующие вас моменты и показали ваш профессионализм. Работа в целом Сначала убедитесь, что это именно то, чем вы хотите заниматься изо дня в день в обозримом будущем. Как выглядит типичный рабочий день? Что из себя представляют проекты, которыми необходимо будет заняться в первую очередь? Можете ли показать мне примеры проектов, над которыми я буду работать? Какие навыки и какой опыт вы ищете в идеальном кандидате? Что необходимо для того, чтобы стать действительно успешным на этой должности? Какие виды навыков отсутствуют в команде, которые вы хотите получить, наняв нового сотрудника? Какие самые большие проблемы, с которыми предстоит столкнуться человеку на этой позиции? Каков уровень бюджета, с которым мне предстоит работать? Это новая роль в компании? Предполагаете ли Вы, что основной круг обязанностей для этой должности изменится в ближайшие полгода-год? Обучение и профессиональное развитие Думайте о каждой новой работе не просто как о работе, а как о следующем шаге на пути к карьерному (или какому-либо иному) успеху. Как эта должность поможет вам его добиться? Как я буду обучаться? Какие учебные программы доступны для ваших сотрудников? Какие существуют возможности карьерного роста и профессионального развития? Смогу ли я представлять компанию на отраслевых конференциях? Куда перешёл предыдущий работник, ранее занимавший эту должность? Как продвигались успешные сотрудники, ранее занимавшие эту должность? Оценка вашего труда Убедитесь, что вы понимаете, какие цели перед вами будут поставлены и то, как ваша работа будет оцениваться. Какие наиболее важные вещи, по вашему мнению, я должен буду сделать за первые 30, 60 и 90 дней работы? Какие результаты от человека на данной позиции ожидаются в течение первых 12 месяцев? Расскажите про систему оценки эффективности деятельности сотрудников в компании. Как часто данный процесс происходит? По каким показателям моя деятельность будет оцениваться? Интервьюер Задавая вопросы интервьюеру вы показываете, что заинтересовались им как человеком, а это отличный способ наладить контакт. Только давайте без комплиментов и лести. Как давно вы работаете в этой компании? Как ваша роль изменилась с тех пор? Чем вы занимались до этой работы? Почему вы устроились в эту компанию? Что вам больше всего нравится в работе здесь? Компания в целом Вы не просто работаете на вашего босса или на ваш отдел, вы работаете \"на\" и \"с\" всей компанией в целом. Я читал о том, как была основана компания, но был бы благодарен, если бы вы смогли рассказать мне больше? Какой вы видите эту компанию в ближайшие несколько лет? Что вы можете рассказать мне о вашей новой продукции и/или планах роста? Каковы главные цели компании в настоящий момент и как она работает над их достижением? Что вас больше всего воодушевляет в будущем компании? Команда Люди, с которыми вам предстоит работать изо дня в день, могут действительно влиять на вашу работу, на желание вставать по утрам и даже на вашу эффективность. Задайте несколько вопросов, чтобы определить, насколько это подходящая для вас команда. Можете ли вы рассказать мне о команде, в которой я буду работать? С кем я буду работать наиболее тесно? Кому я буду непосредственно подчиняться? Можете ли вы рассказать мне о моих прямых подчинённых? Каковы их сильные и слабые стороны? Планируете ли вы нанимать ещё людей в это подразделение в ближайшие шесть месяцев? С какими подразделениями компании придется взаимодействовать чаще всего? Какие общие карьерные перспективы в этом подразделении? Культура Соблюдается в офисе дресс-код или нет? Есть ли жизнь вне офиса? и т.д. Узнайте тонкие, но такие важные детали корпоративной культуры. Какова культура компании в целом и команды в частности? Какие главные аспекты вы могли бы выделить? Как бы вы описали рабочую среду здесь, это, как правило, работа в команде или по одиночке? Можете ли вы рассказать мне о последнем совместном командном мероприятии? Какие у компании миссия и ценности? (Примечание: убедитесь, что данную информацию невозможно \"загуглить\" — в таком случае не задавайте этот вопрос). Какая ваша любимая офисная традиция? Что вы обычно делаете во время обеденного перерыва? (Конечно, помимо самого обеда). Собираются ли сотрудники компании/команды вне офиса? Вы когда-нибудь организовывали совместные мероприятия с другими компаниями или отделами? Что отличает работу здесь от других мест, где вы работали? Как изменилась компания с момента вашего прихода? Следующие шаги Перед уходом убедитесь, что интервьюер получил всю необходимую ему информацию. Для того, чтобы выяснить, как будут развиваться события дальше, задайте эти вопросы. Насколько, по вашему мнению, моя квалификация соответствует данной роли? Каковы следующие шаги по процессу рассмотрения на данную позицию? Что ещё с моей стороны может понадобиться? Могу ли я ответить на какие-либо ещё интересующие вас вопросы? ©megamozg","tags":"copy\\paste","title":"52 вопроса, которые вы должны задать на собеседовании"},{"url":"https://stonedastronaut.github.io/novye-komandy-v-linux-dlia-starykh-reshenii.html","text":"Собственно копипаста отсюда вместо netstat используем ss : ss -lpn вместо ifconfig используем ip addr : Раньше для вкл/выкл определенного интерфейса использовали ifconfig eth0 up теперь так: ip link set dev eth0 up Для конфигурирования интерфейса: ifconfig eth0 10.0.0.2/16 теперь: ip addr dev eth0 add 10.0.0.2/16 вместо ps aux | grep ... используем pgrep -af ps aux | grep rtorrent теперь: pgrep -af rtorrent","tags":"linux","title":"Новые команды в Linux для старых решений"},{"url":"https://stonedastronaut.github.io/postroenie-sviazei-v-sqlalchemy.html","text":"Связи в sqlachemy бывают 4-х видов: OTM (one-to-many) - один к многим MTO (many-to-one) - многие к одному OTO (one-to-one) - один к одному MTM (many-to-many) - многие к многим Релизация этих связей: OTM : Для указания связи OTM, создается колонка с ForeignKey в дочернем классе. При этом сама связь (relationship()) объявляется в Родителе. Для того что-бы получить по Ребенку Родителя, необходимо указать в relationship, свойство backref. class Parent ( Base ): __tablename__ = 'parents' id = Column ( Integer , primary_key = True ) child = relationship ( \"Child\" , backfer = 'parents' ) class Child ( Base ): __tablename__ = 'childrens' id = Column ( Integer , primary_key = True ) parent_id = Column ( Integer , ForeignKey ( 'parents.id' ) MTO : Здесь построение отношения похоже на предыдущий, только ForeignKey указывается в Родителе, вместе с relationship() class Parent ( Base ): __tablename__ = 'parents' id = Column ( Integer , primary_key = True ) child_id = Column ( Integer , ForeignKey ( 'childs.id' )) child = relationship ( \"Child\" , backref = 'parents' ) class Child ( Base ): __tablename__ = 'childs' id = Column ( Integer , primary_key = True ) OTO : Со связью один-к-одному вообще всё просто, это та же связь один-к-многим, только в relationship добавляется еще одно свойство, которое вытягивает из другой таблицы только 1 элемент class Parent ( Base ): __tablename__ = 'parents' id = Column ( Integer , primary_key = True ) child = relationship ( \"Child\" , uselist = False , backref = 'parents' ) class Child ( Base ): __tablename__ = 'childs' id = Column ( Integer , primary_key = True ) parent = Column ( Integer , ForegnKey ( parents . id )) Или class Parent ( Base ): __tablename__ = 'parents' id = Column ( Integer , primary_key = True ) child_id = Column ( Integer , ForeignKey ( 'childs.id' )) child = relationship ( \"Child\" , backref = backref ( \"parents\" , uselist = False )) class Child ( Base ): __tablename__ = 'childs' id = Column ( Integer , primary_key = True ) MTM : Данная связь реализуется при помощи вспомагательной ассоциативной таблицы, которую необходимо создать до создания связанных таблиц. association_table = Table ( 'association' , Base . metadata , Column ( 'left_id' , Integer , ForeignKey ( 'left.id' )), Column ( 'right_id' , Integer , ForeignKey ( 'right.id' )) class Parent ( Base ): __tablename__ = 'left' id = Column ( Integer , primary_key = True ) children = relationship ( \"Child\" , secondary = association_table ) class Child ( Base ): __tablename__ = 'right' id = Column ( Integer , primary_key = True ) стырено из официальной документации с вольным переводом оф.документация","tags":"python","title":"Построение связей в SQLAlchemy"},{"url":"https://stonedastronaut.github.io/kak-vykachat-sait-wget.html","text":"Для выкачки сайта при помощи wget над использовать сл ключи: wget -r -k -l 7 -p -E -nc http://site.com/ -r — указывает на то, что нужно рекурсивно переходить по ссылкам на сайте, чтобы скачивать страницы. -k — используется для того, чтобы wget преобразовал все ссылки в скаченных файлах таким образом, чтобы по ним можно было переходить на локальном компьютере (в автономном режиме). -p — указывает на то, что нужно загрузить все файлы, которые требуются для отображения страниц (изображения, css и т.д.). -l — определяет максимальную глубину вложенности страниц, которые wget должен скачать (по умолчанию значение равно 5, в примере мы установили 7). В большинстве случаев сайты имеют страницы с большой степенью вложенности и wget может просто «закопаться», скачивая новые страницы. Чтобы этого не произошло можно использовать параметр -l. -E — добавлять к загруженным файлам расширение .html. -nc — при использовании данного параметра существующие файлы не будут перезаписаны. Это удобно, когда нужно продолжить загрузку сайта, прерванную в предыдущий раз. --no-parent - не скачивать выше указанного каталога/ссылки. стырено отсюда Некоторые сайты, например мне попался один вики-сайт, который таким образом выкачиватся не желал. Для такого сработала такая комбинация ключей: wget -k -p -r -l 1 --restrict-file-names = nocontrol,windows --html-extension \\ -e robots = off http://tralala.com Скорее всего это связано с шаблоном ссылок внутри сайта, http://.../index.php@some_page, но я не проверял.","tags":"linux","title":"Как выкачать сайт. wget"},{"url":"https://stonedastronaut.github.io/kak-poschitat-plotnost-pikselei-dpi.html","text":"Для подсчета DPI воспользуемся формулой: c&#94;2 = a&#94;2 + b&#94;2 где c - дагональ экрана умноженая на DPI (inch * dpi), a и b - стороны экрана в пикселях. отсюда следует: (inch * dpi)&#94;2 = a&#94;2 + b&#94;2 отсюда вывести dpi, думаю ниукого не составит труда.","tags":"unsort","title":"Как посчитать плотность пикселей (DPI)"},{"url":"https://stonedastronaut.github.io/diagnostika-hdd-sredstvami-unix.html","text":"Здесь я опишу способы проверки hdd, стыренные из других источников, которые мне очень помогли понять, почему у меня тупит комп. Для теста hdd использую 3 утилиты: smartctl из пакета smartmontools hdparm badblocks из пакета e2fsprogs Все тесты проводить на НЕ смонтированном hdd. smartctl: # smartctl -a /dev/sdX отсюда интересует несколько параметров: 5 Reallocated_Sector_Ct - указывает на количество использованных запасных блоков, заложенных \"про запас\" в случае когда hdd начинает сыпаться; 9 Power_On_Hours - название говорит само за себя, сколько бедный hdd отмаслал часов; hdparm: # hdparm -t /dev/sdX Команда покажет, скорость записи на hdd. Данную команду необходимо выполнить несколько раз, для б/м достоверной картины. badblocks: # badblocks -vs /dev/sdX Команда с говорящим названием покажет, сколько битых блоком имеет поверхность hdd. Пояснение к ключам: -w — разрешает запись на жесткий диск, не заботясь о сохранности данных. Никогда не используйте для дисков, на которых есть нужная вам информация! Несколько ускоряет тестирование. -v — выводит информацию об ошибках на экран. -s — выводит статус выполнения проверки в %. Для жесткого диска большого объема проверка может длиться несколько часов, поэтому, возможно, вам захочется наблюдать за ходом выполнения в процентах. Эта опция несколько замедляет работу утилиты, поэтому, если вы запускаете проверку, например, на ночь, эту опцию можно опустить. стырено отсюда","tags":"linux","title":"Диагностика hdd средствами unix"},{"url":"https://stonedastronaut.github.io/backup-hdd-sredstvami-gnulinux.html","text":"После теста hdd можно определить, пора ли менять диск или нет. Если время пришло, то тогда необходимо перенести со старого жесткого всю инфу на новый. Из гуглежа, стало ясно, чо использование обычного dd не \"кошегно\". Ъ использовать GNU ddrescue . Команда для backup'а выглядит следующим образом: # ddrescue /dev/sdX /pth_to_backup/disk.img /pth_to_backup/disk.img.log Можно делать backup как раздела, так и всего hdd. Для просмотра содержимого раздела используем следующую команду: # mount -o loop /pth_to_backup/drive.img /mnt А для образа физического диска : # losetup --partscan /dev/loop0 drive.img # mount /dev/loop0p2 /mnt или, # kpartx -a /dev/loop0 drive.img # mount /dev/mapper/loop0p2 /mnt в зависимости от дистра. Восстановление из образа: # ddrescue --force disk.img /dev/sdxX disk.img.log !!! раздел на который идет восстановление должен быть НЕ меньше файла-образа стырено изхабра","tags":"linux","title":"Backup hdd средствами GNU/Linux"},{"url":"https://stonedastronaut.github.io/sravnenie-katalogov-v-unix-diff.html","text":"Сравнение каталогов утилитой diff осуществляется следующим образом: $ diff -urN dir1 dir2 > out.diff $ mc -e out.diff где ключи diff -u унифицированный метод -r рекурсивно -N При сравнении каталогов, если файл найден только в одном каталоге, считает что он находится и во втором, но является пустым. См. \"Сравнение каталогов\". Возможно использование 'diff' для сравнения некоторых или всех файлов в двух каталогах. Когда оба аргумента-имена файлов для 'diff' ­ каталоги, он сравнивает каждый файл, содержащийся в обоих каталогах, в алфавитном порядке имен файлов. Обычно 'diff' не упоминает о парах неотличающихся файлов, но с опцией '-s' или '--report-identical-files', он будет сообщать и о таких парах. Обычно 'diff' сообщает о подкаталогах, общих для обоих каталогов, не сравнивая файлы в них, но с помощью опции '-r' или '--recursive', он бужет сравнивать соответствующие файлы в дереве каталогов, опускаясь до самых глубоких каталогов. Для имен файлов, содержащихся только в одном каталоге, 'diff' обычно не показывает текста этих файлов, сообщая только, что файлы находятся в одном каталоге и отсутствуют в другом. Можно заставить 'diff' поступать так, как если бы соответствующие файлы существовали и в другом каталоге, но являлись пустыми, тогда в результатах будет присутствовать полный текст таких файлов. (Такие отличия будут рассматриваться как вставки или удаления, в зависимости от того существует файл в первой или второй директории.) Чтобы добиться этого используйте опцию '-N' или '--new-file'. Если в более старом каталоге содержится один или более больших файлов, не содержащихся в более новом, можно уменьшить patch с помощью опции '-P' или '--unidirectional-new-file' вместо '-N'. Эта опция подобна '-N', за исключением того, что она вставляет только содержимое файлов, появившихся во втором каталоге, а не в первом (т.е. добавленных файлов). В начале patch пишется инструкция для пользователей, применяющих patch, - стереть удаленные файлы, перед применением (см. подробнее о составлении patch-ей: \"Составление patch-ей\"). Для игнорирования некоторых файлов при сравнении каталогов, используйте опцию '-x PATTERN' или '--exclude=PATTERN'. Эта опция игнорирует все файлы или поддиректории, чьи базовые имена соответствуют шаблону оболочки PATTERN. В отличие от оболочки, точка в начале имени файла рассматривается так же, как символ . Следует заключать PATTERN в апострофы, чтобы оболочка не истоловала их неправильно. Например, опция '-x ' .[ao]'' игнорирует все файлы, имена которых заканчиваются на '.a' или '.o'. Информация, указанная в этой опции, сохраняется, если ее использовать несколько раз. Например, использование опций '-x 'RCS' -x '*,v'' задает игнорирование всех файлов и подкаталогов, имеющих имя 'RCS' или заканчивающихся на ',v'. Если необходимо использовать эту опцию по несколько раз, можно вместо этого поместить шаблоны в файл, по одному на строку и использовать опцию '-X FILE' или '--exclude-from=FILE'. Если два каталога находились в процессе сравнения и этот процесс был прерван, позже возможно вернуться к сравнению и продолжить его с того же места с помощью опции '-S FILE' или '--starting-file=FILE'. После этого сравниваться будут только файл и FILE и следующеи за ним в алфавитном порядке, в верхнем уровне директории. Стырено с rus-linux.net и genaev.com","tags":"linux","title":"Сравнение каталогов в *unix. diff"},{"url":"https://stonedastronaut.github.io/kak-sozdat-wiki-stranitsu-v-vkcom.html","text":"Чтобы создать wiki страницу в vk.com, необходимо перейти по ссылке следующего вида: http://vk.com/pages?oid=-{Community_id}&p={Name_of_page} где {Community_id} - id паблика или группы, а {Name_of_page} - название страницы, которую необходио создать.","tags":"unsort","title":"Как создать wiki-страницу в vk.com"},{"url":"https://stonedastronaut.github.io/using-websockets-with-spring-angularjs-and-sockjs-en.html","text":"A while ago I wrote a tutorial about writing a web application using Spring, AngularJS and WebSockets. However, that tutorial only used a fraction of what WebSockets could do, so in this tutorial I will explain how you can write a small chat app using the same frameworks; Spring, AngularJS, Stomp.js and SockJS. The entire application will be written using JavaConfig, even the web.xml (what I still kept in my previous tutorial) will be replaced by a WebAppInitializer. The application we're going to write will look like this: Why WebSockets Once upon a time, someone decided to write a mail list application. At first, he made a client that would check if there was a new mail every minute. However, most of the time there was no new mail, yet the client was always sending new request, causing a huge load on the server. This technique was quite popular, and was called polling. Then after a while, they used a new technique, where the client would check if there was new mail, and the server would respond as soon as there was mail available. This technique was a bit better than polling, but you still had to send a request, causing a lot of unnecessary (blocking) traffic, we called this technique long polling. When you start thinking, the only conclusion you can make is that the server should send a message to the client as soon as there is mail available. The client should not initiate the request, but the server should do that. This was impossible for a long time, but since WebSockets where introduced, it finally became possible. WebSockets is a protocol and a JavaScript API, the protocol is a very low level, full-duplex protocol, which means that messages can be sent in both directions simultaneous. It made it possible for the server to send data to the client, in stead of doing the opposite. Polling and long-polling were no longer necessary, and they lived happily ever after. Because WebSockets provide a way to communicate in both ways, they're often used for realtime applications. If for example, someone opened your application and modifies some data, you can directly update the visualized data for all users by using WebSockets. Project setup You will need several libraries here, mainly the Spring Web MVC framework for setting up our web application and Spring messaging + WebSockets for the WebSocket part of the application. We also need a JSON serializer like Jackson, because Stomp needs JSON serialization/deserialization, so I'm going to add those to our application as well. ... <dependency> <groupId> org.springframework </groupId> <artifactId> spring-webmvc </artifactId> <version> 4.1.1.RELEASE </version> </dependency> <dependency> <groupId> org.springframework </groupId> <artifactId> spring-websocket </artifactId> <version> 4.1.1.RELEASE </version> </dependency> <dependency> <groupId> org.springframework </groupId> <artifactId> spring-messaging </artifactId> <version> 4.1.1.RELEASE </version> </dependency> <dependency> <groupId> javax.websocket </groupId> <artifactId> javax.websocket-api </artifactId> <version> 1.0 </version> <scope> provided </scope> </dependency> <dependency> <groupId> javax.servlet </groupId> <artifactId> javax.servlet-api </artifactId> <version> 3.1.0 </version> <scope> provided </scope> </dependency> <dependency> <groupId> javax.servlet </groupId> <artifactId> jstl </artifactId> <version> 1.2 </version> </dependency> <dependency> <groupId> com.fasterxml.jackson.core </groupId> <artifactId> jackson-core </artifactId> <version> 2.3.3 </version> </dependency> <dependency> <groupId> com.fasterxml.jackson.core </groupId> <artifactId> jackson-databind </artifactId> <version> 2.3.3 </version> </dependency> <dependency> <groupId> com.fasterxml.jackson.jaxrs </groupId> <artifactId> jackson-jaxrs-json-provider </artifactId> <version> 2.3.3 </version> </dependency> ... In the front-end I'm going to need some libraries as well, which I will setup using Bower. If you're not into Bower, you can always download the libraries by yourself. { \"name\" : \"spring-ng-chat\" , \"version\" : \"0.0.1-SNAPSHOT\" , \"dependencies\" : { \"sockjs\" : \"0.3.4\" , \"stomp-websocket\" : \"2.3.4\" , \"angular\" : \"1.3.8\" , \"lodash\" : \"2.4.1\" } } The libraries I'm going to use are SockJS + Stomp.js for communication through WebSockets, AngularJS will be used for setting up the client-part of the application and Lo-Dash is a utility library that I will use (a fork of Underscore.js). What is STOMP? Like I said before, the WebSocket protocol is a pretty low-level protocol, however, there are a few high(er) level protocols that can be used on top of WebSockets, for example MQTT and STOMP. STOMP for example adds extra possibilities to WebSockets, like publishing and subscribing to topics. Java config In stead of configuring our application using XML's, I'm going to show you how you could write the same application, without the need of any XML file. The first class we need is the replacement of our web.xml, to bootstrap our web application. In this class we can define our application context(s), our web application context and some other servlet related configuration. public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { @Override protected void customizeRegistration ( ServletRegistration . Dynamic registration ) { registration . setInitParameter ( \"dispatchOptionsRequest\" , \"true\" ); registration . setAsyncSupported ( true ); } @Override protected Class < ?>[] getRootConfigClasses () { return new Class < ?>[] { AppConfig . class , WebSocketConfig . class }; } @Override protected Class < ?>[] getServletConfigClasses () { return new Class < ?>[] { WebConfig . class }; } @Override protected String [] getServletMappings () { return new String [] { \"/\" }; } @Override protected Filter [] getServletFilters () { CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter (); characterEncodingFilter . setEncoding ( StandardCharsets . UTF_8 . name ()); return new Filter [] { characterEncodingFilter }; } } Most of this class is quite clear. First of all we have our getRootConfigClasses() and getServletConfigClasses() which we use to define our bean configuration classes. The getServletMappings() and getServletFilters() are related to servlet configuration. In this case I'm mapping the application to the context root and I'm adding a filter to make sure all content is in UTF-8 . Then the final method here is the customizeRegistrion . This can be quite important if you're running the application on a Tomcat container. It says that asynchronous communication is possible, so that connections do not have to be closed directly. As you might notice, you will get three compilation errors of classes that are not found. I'm going to define those now, so let's start with AppConfig : @Configuration @ComponentScan ( basePackages = \"be.g00glen00b\" , excludeFilters = { @ComponentScan.Filter ( value = Controller . class , type = FilterType . ANNOTATION ), @ComponentScan.Filter ( value = Configuration . class , type = FilterType . ANNOTATION ) }) public class AppConfig { } Quite empty and useless here, it tells which packages to scan, but excludes all configuration and controller classes (configuration classes are bootstrapped by our WebAppInitializer while Controller classes are bound to our WebConfig ). Since we will only need a controller, this class will do nothing special, but if you have special services, then they will become spring beans if annoted correctly. The next class is the WebConfig : @Configuration @EnableWebMvc @ComponentScan ( basePackages = \"be.g00glen00b.controller\" ) public class WebConfig extends WebMvcConfigurerAdapter { @Bean public InternalResourceViewResolver getInternalResourceViewResolver () { InternalResourceViewResolver resolver = new InternalResourceViewResolver (); resolver . setPrefix ( \"/WEB-INF/views/\" ); resolver . setSuffix ( \".jsp\" ); return resolver ; } @Override public void configureDefaultServletHandling ( DefaultServletHandlerConfigurer configurer ) { configurer . enable (); } @Bean public WebContentInterceptor webContentInterceptor () { WebContentInterceptor interceptor = new WebContentInterceptor (); interceptor . setCacheSeconds ( 0 ); interceptor . setUseExpiresHeader ( true ); interceptor . setUseCacheControlHeader ( true ); interceptor . setUseCacheControlNoStore ( true ); return interceptor ; } @Override public void addResourceHandlers ( ResourceHandlerRegistry registry ) { registry . addResourceHandler ( \"/libs/**\" ). addResourceLocations ( \"/libs/\" ); registry . addResourceHandler ( \"/app/**\" ). addResourceLocations ( \"/app/\" ); registry . addResourceHandler ( \"/assets/**\" ). addResourceLocations ( \"/assets/\" ); } @Override public void addInterceptors ( InterceptorRegistry registry ) { registry . addInterceptor ( webContentInterceptor ()); } } This configuration class bootstraps our web context. It tells us which static resources can be served (with addResourceHandlers . It adds a no cache interceptor ( webContentInterceptor() and addInterceptors() ) and also tells us the location of our dynamic resources ( JSP files) by using the getInternalResourceViewResolver() bean. Then finally we also have the WebSocket configuration: @Configuration @EnableWebSocketMessageBroker @ComponentScan ( basePackages = \"be.g00glen00b.controller\" ) public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker ( MessageBrokerRegistry config ) { config . enableSimpleBroker ( \"/topic\" ); config . setApplicationDestinationPrefixes ( \"/app\" ); } @Override public void registerStompEndpoints ( StompEndpointRegistry registry ) { registry . addEndpoint ( \"/chat\" ). withSockJS (); } } Just like the WebConfig it has to scan components in the controller package as well, because we will map our WebSocket traffic onto our controllers. Then we have to configure the message broker (where communication enters and leaves) using configureMessageBroker and we also have to configure our endpoints using registerStompEndpoints . WebSockets are not yet working in all browsers. Many WebSockets libraries (for example SockJS and Socket.io) provide fallback-options using long polling, polling, … . Spring also allows these fallbacks, and is compatible with SockJS. This is why choosing SockJS as the client is a good idea. Data transfer object Our main communication will happen through WebSockets. To communicate, we will send a certain payload and respond to a specific Stomp.js topic. We need two classes for it, Message and OutputMessage . First of all, Message will contain the chat message itself, and a generated ID, for example: public class Message { private String message ; private int id ; public Message () { } public Message ( int id , String message ) { this . id = id ; this . message = message ; } public String getMessage () { return message ; } public void setMessage ( String message ) { this . message = message ; } public int getId () { return id ; } public void setId ( int id ) { this . id = id ; } } The OutputMessage will extend Message , but will also add a timestamp (the current date) to it: public class OutputMessage extends Message { private Date time ; public OutputMessage ( Message original , Date time ) { super ( original . getId (), original . getMessage ()); this . time = time ; } public Date getTime () { return time ; } public void setTime ( Date time ) { this . time = time ; } } Spring controller The final step in the Java-part of our application is the controller itself, with two mappings; one for the HTML/JSP page that contains our application, and the other for the WebSocket traffic: @Controller @RequestMapping ( \"/\" ) public class ChatController { @RequestMapping ( method = RequestMethod . GET ) public String viewApplication () { return \"index\" ; } @MessageMapping ( \"/chat\" ) @SendTo ( \"/topic/message\" ) public OutputMessage sendMessage ( Message message ) { return new OutputMessage ( message , new Date ()); } } What happens here is quite easy, when we go to the context root, we will see that viewApplication() is mapped onto that, so that the index.jsp page is used as the view. The other method, sendMessage() allows us to broadcast a message to /topic/message when a message entes the messagebroker /app/chat (don't forget that we defined the prefix /app in WebSocketConfig ). The view Now our entire Java code is already written, let's start by defining the JSP page. This page will contain two main components; the form to add a new message, and the message list itself. <!DOCTYPE HTML> <html lang= \"en\" > <head> <link href= \"http://fonts.googleapis.com/css?family=Open+Sans:400,300,600,700\" rel= \"stylesheet\" type= \"text/css\" /> <link href= \"assets/style.css\" rel= \"stylesheet\" type= \"text/css\" /> </head> <body ng-app= \"chatApp\" > <div ng-controller= \"ChatCtrl\" class= \"container\" > <form ng-submit= \"addMessage()\" name= \"messageForm\" > <input type= \"text\" placeholder= \"Compose a new message...\" ng-model= \"message\" /> <div class= \"info\" > <span class= \"count\" ng-bind= \"max - message.length\" ng-class= \"{danger: message.length > max}\" > 140 </span> <button ng-disabled= \"message.length > max || message.length === 0\" > Send </button> </div> </form> <hr /> <p ng-repeat= \"message in messages | orderBy:'time':true\" class= \"message\" > <time> {{ message.time | date :'HH:mm' }} </time> <span ng-class= \"{self: message.self}\" > {{ message.message }} </span> </p> </div> <script src= \"libs/sockjs/sockjs.min.js\" type= \"text/javascript\" ></script> <script src= \"libs/stomp-websocket/lib/stomp.min.js\" type= \"text/javascript\" ></script> <script src= \"libs/angular/angular.min.js\" ></script> <script src= \"libs/lodash/dist/lodash.min.js\" ></script> <script src= \"app/app.js\" type= \"text/javascript\" ></script> <script src= \"app/controllers.js\" type= \"text/javascript\" ></script> <script src= \"app/services.js\" type= \"text/javascript\" ></script> </body> </html> First of all we're adding the Open Sans font and our own stylesheet (which we will define later in this tutorial). Then we start the body and bootstrap our AngularJS application which we will call chatApp . In this application we will have one AngularJS controller, the ChatCtrl . Don't confuse this one with our Spring controller! The first thing we have to do is create form that has a text field. We're binding this text-field to the model called message . When the form is submit, the addMessage() function on our controller will be called, which we will use to send the message using websockets. To make the form a bit fancier, we also added a counter similar to how Twitter works. The moment you enter too many characters ( max ), it will turn red and you can no longer submit the form thanks to the ng-disabled directive. Below the form we loop through the messages and for each message we print the time and the message. If the message originated from the user self, it will have a specific self class, thanks to the ng-class directive. The messages are sorted by their date, with the most recent one at the top of the list. At the end of our page we load all the libraries we need, and our application JavaScript files. Bootstrapping the AngularJS application Our first JavaScript file is app.js. This file will define all module packages, in this case: angular . module ( \"chatApp\" , [ \"chatApp.controllers\" , \"chatApp.services\" ]); angular . module ( \"chatApp.controllers\" , []); angular . module ( \"chatApp.services\" , []); AngularJS controller The AngularJS controller will be quite easy as well, as it will forward everything to a seperate service we will write later in this tutorial. The controller contains three model related fields, the message which will contain the currently typed message in the textbox, the messages array which contains all received messages and also max the maximum allowed characters in a message, used for the Twitter-look-a-like counter. angular . module ( \"chatApp.controllers\" ). controller ( \"ChatCtrl\" , function ( $scope , ChatService ) { $scope . messages = []; $scope . message = \"\" ; $scope . max = 140 ; $scope . addMessage = function () { ChatService . send ( $scope . message ); $scope . message = \"\" ; }; ChatService . receive (). then ( null , null , function ( message ) { $scope . messages . push ( message ); }); }); We already explained that when the form is submit, the addMessage is called, which will forward the message to the service, and which will then empty the field by resetting the message model to an empty string. We also call the service for receiving messages. This part of the service will return a deferred, that each time a message is received, updates the progress part of the directive. The controller will react on that message by adding it to the messages array. AngularJS service The last part of our AngularJS based client application is the service. The service is a bit more complex, since it will contain all WebSocket traffic handling code. The code of this service is as follows: angular . module ( \"chatApp.services\" ). service ( \"ChatService\" , function ( $q , $timeout ) { var service = {}, listener = $q . defer (), socket = { client : null , stomp : null }, messageIds = []; service . RECONNECT_TIMEOUT = 30000 ; service . SOCKET_URL = \"/spring-ng-chat/chat\" ; service . CHAT_TOPIC = \"/topic/message\" ; service . CHAT_BROKER = \"/app/chat\" ; service . receive = function () { return listener . promise ; }; service . send = function ( message ) { var id = Math . floor ( Math . random () * 1000000 ); socket . stomp . send ( service . CHAT_BROKER , { priority : 9 }, JSON . stringify ({ message : message , id : id })); messageIds . push ( id ); }; var reconnect = function () { $timeout ( function () { initialize (); }, this . RECONNECT_TIMEOUT ); }; var getMessage = function ( data ) { var message = JSON . parse ( data ), out = {}; out . message = message . message ; out . time = new Date ( message . time ); if ( _ . contains ( messageIds , message . id )) { out . self = true ; messageIds = _ . remove ( messageIds , message . id ); } return out ; }; var startListener = function () { socket . stomp . subscribe ( service . CHAT_TOPIC , function ( data ) { listener . notify ( getMessage ( data . body )); }); }; var initialize = function () { socket . client = new SockJS ( service . SOCKET_URL ); socket . stomp = Stomp . over ( socket . client ); socket . stomp . connect ({}, startListener ); socket . stomp . onclose = reconnect ; }; initialize (); return service ; }); So, let's first start with the bottom. At the bottom of the code you can see that we execute the initialize() function for setting up the service. This will happen exactly once, since AngularJS services are singletons, meaning that each time the same instance is returned. The initialize() function will set up the SockJS Websocket client and use it for the Stomp.js websocket client. Stomp.js is an addition to the Websocket protocol which allows subscribing and publishing to topics and also allows JSON payloads. When the client is connected to the WebSocket server, then the startListener() function is called, which will listen to the /topic/message topic on which all messages will be received. It will then send the data to the deferred which will be used by the controllers. The startListener() function calls the getMessage() function which will translate the Websocket data body (= payload) to the model required by the controller. In this case it will parse the JSON string to an object, and it will set the time as a Date object. If the message ID is listed in the messageIds array, then it means the message originated from this client, so it will set the self property to true . Afterwards it will remove that message ID from the list, so that it's available again inside the message ID pool. When the connection to the Websocket server is lost, it will call the reconnect() function which will attempt to initialize the connection again after 30 seconds. Lastly, we have the two public functions of our service, receive() and send() . Let's start with the receive() function since this is the easiest of the two. The only thing this function does is returning the deferred used to send messages at. The send() function on the other hand sends the message as a JSON object (stringified) and with a newly generated ID. This ID is added to the messageIds array, so that it can be used by the getMessage() function to check if the message was added by this client or by another client. Styling That was all Java and JavaScript code we need, so let's finish our application by giving it some cool styles. I'm using the following CSS code: body , * { font-family : 'Open Sans' , sans-serif ; box - sizing : border - box ; } .container { max-width : 1000px ; margin : 0 auto ; width : 80% ; } input [ type = text ] { width : 100% ; border : solid 1px #D4D4D1 ; transition : .7s ; font-size : 1.1em ; padding : 0.3em ; margin : 0.2em 0 ; } input [ type = text ] :focus { - webkit - box - shadow : 0 0 5px 0 rgba ( 69 , 155 , 231 , . 75 ); - moz - box - shadow : 0 0 5px 0 rgba ( 69 , 155 , 231 , . 75 ); box - shadow : 0 0 5px 0 rgba ( 69 , 155 , 231 , . 75 ); border-color : #459be7 ; outline : none ; } .info { float : right ; } form :after { display : block ; content : '' ; clear : both ; } button { background : #459be7 ; color : #FFF ; font-weight : 600 ; padding : .3em 1.9em ; border : none ; font-size : 1.2em ; margin : 0 ; text-shadow : 0 0 5px rgba ( 0 , 0 , 0 , . 3 ); cursor : pointer ; transition : .7s ; } button :focus { outline : none ; } button :hover { background : #1c82dd ; } button :disabled { background-color : #90BFE8 ; cursor : not - allowed ; } .count { font-weight : 300 ; font-size : 1.35em ; color : #CCC ; transition : .7s ; } .count.danger { color : #a94442 ; font-weight : 600 ; } .message time { width : 80px ; color : #999 ; display : block ; float : left ; } .message { margin : 0 ; } .message .self { font-weight : 600 ; } .message span { width : calc ( 100% - 80px ); display : block ; float : left ; padding-left : 20px ; border-left : solid 1px #F1F1F1 ; padding-bottom : .5em ; } hr { display : block ; height : 1px ; border : 0 ; border-top : solid 1px #F1F1F1 ; margin : 1em 0 ; padding : 0 ; } Demo Before running our application on a webserver, check some things first. First of all, make sure you have set your context root to /spring-ng-chat/ . If you don't do that, your AngularJS service will have troubles connecting to the WebSocket server, as it connects to /spring-ng-chat/chat . If you don't want this, you can always change the SOCKET_URL property in the AngularJS service. Second, if you're running this application from an embedded Tomcat in Eclipse, you may have to add your Maven dependencies to your deployment assembly. You can do this by going to your project properties, clicking on Deployment assembly and by adding the library. Finally, make sure that the web container you're using, supports the WebSockets Java API. If this isn't the case, you will probably have to update your web container. If all of that is ready, then you can start running your application, which should look like this: If you start writing your message, you will see that the button is now enabled and that the counter is running: If you go too far, you will see that the button is now disabled again, and the counter is now showing a negative value in a red color: Once you enter a message and send it, you will see that it appears in the message list as a bold message (because you sent it). You will also see that your current message is reset to an empty string in the text box: If you open the application in a new window, you should see that it is empty now. WebSockets are real time, so only messages that are received at a given time, will be listed, there is no history. If you send a message in the other window, you will see that the message appears in both screens. One will have it in bold, while the other one will see it as regular text. As you can see, the WebSockets are working properly and you will see the messages appear real time because the client sends the message to the server, which will in turn send the message to all clients. This server-client message model is only possible thanks to WebSockets. Achievement: Wrote a chat application with Spring, AngularJS and SockJS Seeing this means you finished this tutorial about writing a simple chat application using WebSockets with Spring, AngularJS and SockJS. If you're interested in the full code example, you can find it on Github . If you want to try out the code yourself, you can download an archive from Github .","tags":"java","title":"Using WebSockets with Spring, AngularJS and SockJS"},{"url":"https://stonedastronaut.github.io/10-zapovedei-bezlichnogo-programmirovaniia-en.html","text":"From The Psychology of Computer Programming, written in 1971, here are The Ten Commandments of Egoless Programming: Understand and accept that you will make mistakes. The point is to find them early, before they make it into production. Fortunately, except for the few of us developing rocket guidance software at JPL, mistakes are rarely fatal in our industry. We can, and should, learn, laugh, and move on. You are not your code. Remember that the entire point of a review is to find problems, and problems will be found. Don't take it personally when one is uncovered. No matter how much \"karate\" you know, someone else will always know more. Such an individual can teach you some new moves if you ask. Seek and accept input from others, especially when you think it's not needed. Don't rewrite code without consultation. There's a fine line between \"fixing code\" and \"rewriting code.\" Know the difference, and pursue stylistic changes within the framework of a code review, not as a lone enforcer. Treat people who know less than you with respect, deference, and patience. Non-technical people who deal with developers on a regular basis almost universally hold the opinion that we are prima donnas at best and crybabies at worst. Don't reinforce this stereotype with anger and impatience. The only constant in the world is change. Be open to it and accept it with a smile. Look at each change to your requirements, platform, or tool as a new challenge, rather than some serious inconvenience to be fought. The only true authority stems from knowledge, not from position. Knowledge engenders authority, and authority engenders respect – so if you want respect in an egoless environment, cultivate knowledge. Fight for what you believe, but gracefully accept defeat. Understand that sometimes your ideas will be overruled. Even if you are right, don't take revenge or say \"I told you so.\" Never make your dearly departed idea a martyr or rallying cry. Don't be \"the coder in the corner.\" Don't be the person in the dark office emerging only for soda. The coder in the corner is out of sight, out of touch, and out of control. This person has no voice in an open, collaborative environment. Get involved in conversations, and be a participant in your office community. Critique code instead of people – be kind to the coder, not to the code. As much as possible, make all of your comments positive and oriented to improving the code. Relate comments to local standards, program specs, increased performance, etc. I keep this list around even today. It has already helped me be a better programmer. Sometimes I imagine what other bits of advice he'd give me were he still around. While I cannot know, I feel sure he'd be proud so long as I keep these in mind. © Stephen Wyatt Bush","tags":"copy\\paste","title":"10 заповедей безличного программирования"}]}