title: Строковый пул Java
date: 2015-07-30 21:39:00
status: published
tags: java, programming

***

Строковый пул, или множество строк, Java располагается в области памяти, именуемой **Java Heap** – **куча**, в которой хранятся все переменные, созданные программно вашим приложением. Естественно, появление этой структуры связано с оптимизацией способов хранения строк как объектов в языке.

Тип **String** – один из самых часто используемых в Java и довольно дорогой для хранения: **4**-символьная строка занимает **56 байт** памяти, т.е. реальные данные (4 символа) занимают только **14%** выделенной под объект памяти. В связи с этим возникает необходимость оптимизировать способ хранения строк в памяти виртуальной машины. Так, было решено использовать подход Flyweight (*приспособленец*): если используется множество одинаковых данных (объектов), то гораздо экономнее создать только *один* экземпляр, чем несколько копий.

***

## 1. Работа пула на примерах.

Давайте рассмотрим следующий пример:

    :::java
    public class StringConcatenationExample
    {
        public static void main(String[] args)
        {
            String str1 = "abc";
            String str2 = "abc";

            System.out.println(str1 == str2);
            System.out.println(str1 == "abc");
        }
    }

Выводом этого фрагмента кода будет следующее:

    :::bash
	true
	true

Как видите, `str1` и `str2` ссылаются на один и тот же объект (т.к. равенство `==` будет достигнуто только в случае равенства ссылок). Изобразить это можно следующим образом:

![Java Pool][pool]

Как видите, если вы создаете новый объект `String` и вручную, т.е. литерами, задаете его значение (`"Hello, world"`), а объект с таким значением уже есть в пуле, то новая строка не создается, а просто переменная, являющаяся указателем, ссылается на уже созданный объект с тем же значением. Равенство, естественно, проверяется методом `String.equals(String)`. Таким образом, строковые переменные, имеющие при инициализации одинаковые значения, будут указывать на один и тот же объект.

Теперь вы понимаете, почему строки в Java являются неизменяемыми: если бы в одном потоке была создана строка, и с таким же значением в другом потоке была бы создана еще одна строка, то изменение строки в одном из потоков повлекло бы ее изменение в другом.

Сравним результат выполнения предыдущего фрагмента кода с этим:

    :::java
    public class StringConcatenationExample
	{
	    public static void main(String[]args)
    	{
	        String str1 = "abc";
    		String str2 = "abc";
	        String str3 = new String("abc");

            System.out.println(str1 == str2);
            System.out.println(str1 == str3);
        }
    }

Вывод в данном случае будет:

    :::bash
    true
    false

т.к. объекты, на которые указывают `str1` и `str3` уже отличаются, ведь для создания `str3` был вручную вызван конструктор (`new`), что повлекло создание нового объекта. И теперь этот объект помещается не в строковом пуле, а в "обычном" сегменте памяти JVM.

Теперь рассмотрим такой пример:

    :::java
    public class StringConcatenationExample
	{
        public static void main(String[]args)
    	{

            String str1 = "abc";
            String str2 = "ab";

            str2 = str2+"c";

            System.out.println("str1 :" +str1+", str2 :"+str2);
            System.out.println(str1 == str2);
        }
    }

Вывод:

    :::terminal
    str1 :abc, str2 :abc
    false

Как было указано выше, строки в Java, как объекты, изменить нельзя. Поэтому когда в коде программы мы "изменили" `str2` на самом деле был создан новый объект-строка с новым значением. При этом `str1`, очевидно, остался указывать на тот же объект, что и раньше, поэтому равенство `str1 == str2` на этот раз не выполнилось.

Теперь рассмотрим код, где для конкатенации используется `StringBuffer`. Его использование гарантирует то, что строка находится не в строковом пуле, а в "нормальной" области памяти.

    :::java
    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;

    public class StringConcatenationExample
    {
        public static void main(String[]args) throws IOException
        {
            String str1 = "abc";

            BufferedReader bufferRead = new BufferedReader(new InputStreamReader(System.in));
            System.out.print("Type in a string :");
            String str2 = bufferRead.readLine();

            System.out.println("str1 :" +str1+", str2 :"+str2);
            System.out.println(str1 == str2);
        }
    }

Результатом выполнения этого кода будет следующий вывод:

    :::terminal
    Type in a string :abc
    str1 :abc, str2 :abc
    false

Таким образом, в результате тестирования вышележащих сниппетов можно заключить, что строковые переменные будут ссылаться на один и тот же строковый объект только в том случае, если эти объекты были инициализированы одинаковыми значениями.

## 2. Ручное помещение строки в пул

Как мы заметили, строковый пул не всегда используется автоматически. Но что же делать, если его использование может существенно уменьшить количество используемой памяти? Пусть мы создаем класс, описывающий адрес человека. Как известно, более 10 миллионов человек сегодня проживает в Москве. Представляете, как много места может занять использование отдельного объекта-строки для каждого из жителей Москвы? Для того, чтобы вручную поместить строку в пул, необходимо использовать метод `String.intern()`. Рассмотрим пример:

    :::bash
    String s1 = "abc";
    String s2= "abc";

    String s3 = new String("abc");

    System.out.println(s1 == s2);
    System.out.println(s1 == s3);

    s3 = s3.intern();
    System.out.println(s1==s3);

Результат выполнения этого кода будет представлять из себя следующий набор строк:

    :::bash
    true
    false
    true

То есть вызов этого метода равносилен созданию строки, для которой значение введено заново с использованием литер.

Но будьте аккуратны. До Java 7 в памяти существовала отдельная область *PermGen*, в которой и располагался пул, которому было отведено ограниченное количество памяти. Начиная с **Java 7**, строковый пул помещается в **той же** области кучи, **что и все** остальные объекты, что делает строки доступными для сборщика мусора. Указать объем отводимой под строки памяти (которые хранятся в виде хэш-мапа) можно с использованием опции `XX:StringTableSize`. Так Вы, фактически, создаете свой *собственный* пул строк, но впрочем, не забивайте голову.

[*©javacodegeeks*](http://examples.javacodegeeks.com/core-java/lang/string/java-string-pool-example/)
[pool]: /static/img/java_pool.png "Java Pool"
