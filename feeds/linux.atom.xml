<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>astro blog</title><link href="https://ipkalm.github.io/" rel="alternate"></link><link href="https://ipkalm.github.io/feeds/linux.atom.xml" rel="self"></link><id>https://ipkalm.github.io/</id><updated>2015-08-19T01:02:00+06:00</updated><entry><title>Hotkey для броузера в Kde</title><link href="https://ipkalm.github.io/hotkey-dlia-brouzera-v-kde.html" rel="alternate"></link><published>2015-08-19T01:02:00+06:00</published><updated>2015-08-19T01:02:00+06:00</updated><author><name>ipkalm</name></author><id>tag:ipkalm.github.io,2015-08-19:hotkey-dlia-brouzera-v-kde.html</id><summary type="html">&lt;hr /&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;/bin/bash -c &lt;span class="s2"&gt;&amp;quot;`xdg-settings get default-web-broswer | sed &amp;#39;s/.desktop//g&amp;#39;`&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="linux"></category></entry><entry><title>awk, sed, bzip2, grep, wc на всех ядрах</title><link href="https://ipkalm.github.io/awk-sed-bzip2-grep-wc-na-vsekh-iadrakh.html" rel="alternate"></link><published>2015-08-03T17:32:00+06:00</published><updated>2015-08-03T17:32:00+06:00</updated><author><name>ipkalm</name></author><id>tag:ipkalm.github.io,2015-08-03:awk-sed-bzip2-grep-wc-na-vsekh-iadrakh.html</id><summary type="html">&lt;p&gt;Существует такая проблема: вы хотите добавить огромный список (сотни мегабайт) или запустить поиск по регулярному выражению (&lt;strong&gt;grep&lt;/strong&gt;) на нем, или совершить какую-то еще трудно распараллеливаемую операцию. У вас, вероятно, есть четыре ядра или даже больше, но наши проверенные и надежные инструменты &lt;strong&gt;grep&lt;/strong&gt;, &lt;strong&gt;bzip2&lt;/strong&gt;, &lt;strong&gt;wc&lt;/strong&gt;, &lt;strong&gt;awk&lt;/strong&gt;, &lt;strong&gt;sed&lt;/strong&gt; и т.д. однопоточные и будут использовать всего одно ядро. Как сказал бы Картман, «Как мне добраться до этих ядер?» Давайте использовать все четыре ядра нашей Linux-машины с помощью &lt;strong&gt;GNU Parallel&lt;/strong&gt;, небольшой map-reduce магии и малоизвестного параметра &lt;code&gt;--pipes&lt;/code&gt; (также известного как &lt;code&gt;--spreadstdin&lt;/code&gt;). Поверьте, удовольствие от работы прямо пропорционально количеству задействованных ядер!&lt;/p&gt;

&lt;h3 id="bzip2"&gt;BZIP2&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;bzip2&lt;/strong&gt; сжимает лучше, чем &lt;strong&gt;gzip&lt;/strong&gt;, но он такой медленый! К счатью, эта проблема решаема. Просто вместо этого:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cat bigfile.bin &lt;span class="p"&gt;|&lt;/span&gt; bzip2 --best &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;gt&lt;span class="p"&gt;;&lt;/span&gt; compressedfile.bz2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;можно написать вот это:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cat bigfile.bin &lt;span class="p"&gt;|&lt;/span&gt; parallel --pipe --recend &lt;span class="s1"&gt;''&lt;/span&gt; -k bzip2 --best &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;gt&lt;span class="p"&gt;;&lt;/span&gt; compressedfile.bz2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;GNU Parallel&lt;/strong&gt; особенно ускоряет &lt;strong&gt;bzip2&lt;/strong&gt; за счет работы на нескольких ядрах. Дайте ему свободу и вы будете вознаграждены.&lt;/p&gt;
&lt;h3 id="grep"&gt;GREP&lt;/h3&gt;
&lt;p&gt;Если у вас имеется огромный текстовый файл для прогона &lt;strong&gt;grep&lt;/strong&gt;'ом, то лучше используйте вместо этого:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;grep pattern bigfile.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;вот это:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cat bigfile.txt &lt;span class="p"&gt;|&lt;/span&gt; parallel --pipe grep &lt;span class="s1"&gt;'pattern'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;или это:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cat bigfile.txt &lt;span class="p"&gt;|&lt;/span&gt; parallel --block 10M --pipe grep &lt;span class="s1"&gt;'pattern'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;или это:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;parallel --pipepart -a bigfile.txt --block 30m wc -l &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;'{s+=$1} END {print s}'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Вторая рекомендуемая команда показывает, как использовать команду &lt;code&gt;--block&lt;/code&gt; с 10&lt;strong&gt;MB&lt;/strong&gt; данных из вашего файла. С этим параметром можно поиграться, чтобы понять, какой объем данных вы хотите обрабатывать одним ядром. Вот здесь можно посмотреть, как обрабатывать grep'ом не один файл, а несколько.&lt;/p&gt;
&lt;h3 id="awk"&gt;AWK&lt;/h3&gt;
&lt;p&gt;А вот это пример того, как с помощью &lt;strong&gt;awk&lt;/strong&gt; добавить числа в очень большой файл. Вместо этого:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cat rands20M.txt &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;'{s+=$1} END {print s}'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;попробуйте это:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cat rands20M.txt &lt;span class="p"&gt;|&lt;/span&gt; parallel --pipe awk &lt;span class="se"&gt;\'&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;s+&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="se"&gt;\$&lt;/span&gt;1&lt;span class="o"&gt;}&lt;/span&gt; END &lt;span class="o"&gt;{&lt;/span&gt;print s&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="se"&gt;\'&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;'{s+=$1} END {print s}'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Здесь &lt;code&gt;--pipe&lt;/code&gt; позволяет использовать несколько чанков для вызова &lt;strong&gt;awk&lt;/strong&gt;, записывая промежуточные результаты, а которые затем сливаются в конечный.&lt;/p&gt;
&lt;h3 id="wc"&gt;WC&lt;/h3&gt;
&lt;p&gt;Хотите запустить супер-распараллеленный подсчет строк в файле? Тогда вместо этого:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;wc -l bigfile.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;запустите вот это:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cat bigfile.txt &lt;span class="p"&gt;|&lt;/span&gt; parallel --pipe wc -l &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;'{s+=$1} END {print s}'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Вот это уже здорово. Что происходит? При распараллеленном вызове мы направляем несколько вызовов &lt;code&gt;wc -l&lt;/code&gt;, формируя промежуточные результаты, а затем вызываем awk.&lt;/p&gt;
&lt;h3 id="sed"&gt;SED&lt;/h3&gt;
&lt;p&gt;Захотелось сделать огромное количество перемещений в большом файле? Тогда забудьте об этом:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sed s^old^new^g bigfile.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;и используйте вот это:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cat bigfile.txt &lt;span class="p"&gt;|&lt;/span&gt; parallel --pipe sed s^old^new^g
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;... и затем направьте вывод в ваш любимый файл.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.rankfocus.com/use-cpu-cores-linux-commands/"&gt;source&lt;/a&gt;&lt;/p&gt;</summary><category term="linux"></category><category term="grep"></category><category term="awk"></category><category term="sed"></category><category term="bzip2"></category><category term="parallel"></category></entry><entry><title>LVM on LUKS на примере arch</title><link href="https://ipkalm.github.io/lvm-on-luks-na-primere-arch.html" rel="alternate"></link><published>2015-07-26T03:53:00+06:00</published><updated>2015-07-26T03:53:00+06:00</updated><author><name>ipkalm</name></author><id>tag:ipkalm.github.io,2015-07-26:lvm-on-luks-na-primere-arch.html</id><summary type="html">&lt;h2 id="_1"&gt;Создаём разделы физические&lt;/h2&gt;
&lt;p&gt;Вот такая структура диска.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/dev/sda1 -&amp;gt; /boot&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/dev/sda2 -&amp;gt; LVM&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="lvm"&gt;Шифруем раздел LVM&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cryptsetup luksFormat -c aes-xts-plain64 -s &lt;span class="m"&gt;512&lt;/span&gt; /dev/sda2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;больше о параметрах шифрования см. &lt;a href="https://wiki.archlinux.org/index.php/Dm-crypt/Device_encryption#Encryption_options_for_LUKS_mode"&gt;здесь&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cryptsetup open --type luks /dev/sda2 lvm
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="lvm_1"&gt;Создаём разделы на LVM&lt;/h3&gt;
&lt;p&gt;создаём физический раздел LVM:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;pvcreate /dev/mapper/lvm
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;создаём группу разделов LVM:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;vgcreate MyStorage /dev/mapper/lvm
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;создаём логические разделы LVM:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;lvcreate -L 8G MyStorage -n swapvol
lvcreate -L 15G MyStorage -n rootvol
lvcreate -l +100%FREE MyStorage -n homevol
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;форматируем разделы:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mkfs.ext4 /dev/mapper/MyStorage-rootvol
mkfs.ext4 /dev/mapper/MyStorage-homevol
mkswap /dev/mapper/MyStorage-swapvol
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;наконец-то монтируем&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mount /dev/MyStorage/rootvol /mnt
mkdir /mnt/home
mount /dev/MyStorage/homevol /mnt/home
swapon /dev/MyStorage/swapvol
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="boot"&gt;подготавливаем boot&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mkfs.ext2 /dev/sda1
mkdir /mnt/boot
mount /dev/sda1 /mnt/boot
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Дальше идёт обычная установка системы, до момента генерации &lt;strong&gt;initramfs&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Для того, что бы можно было загружаться с lvm надо добавить в &lt;code&gt;/etc/mkinitcpio.conf&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;/etc/mkinitcpio.conf:
&lt;span class="nv"&gt;HOOKS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;... encrypt lvm2 resume ... filesystems ...&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;encrypted&lt;/strong&gt;, &lt;strong&gt;lvm2&lt;/strong&gt; и &lt;strong&gt;resume&lt;/strong&gt; должны стоять перед &lt;strong&gt;filesystems&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="_2"&gt;конфигурация загрузчика&lt;/h3&gt;
&lt;p&gt;Перед генерацией конфига &lt;em&gt;grub&lt;/em&gt;, необходимо добавить информацию о зашифрованных разделах в &lt;code&gt;/etc/default/grub&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;...
&lt;span class="nv"&gt;GRUB_CMDLINE_LINUX_DEFAULT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;quiet resume=/dev/MyStorage/swapvol&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;GRUB_CMDLINE_LINUX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;cryptdevice=/dev/sda2:MyStorage \&lt;/span&gt;
&lt;span class="s2"&gt;root=/dev/mapper/MyStorage-rootvol&amp;quot;&lt;/span&gt;
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Собственно всё.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://wiki.archlinux.org/index.php/Dm-crypt/Encrypting_an_entire_system#LUKS_on_LVM"&gt;ссылка на оригинал&lt;/a&gt;&lt;/p&gt;</summary><category term="linux"></category><category term="crypt"></category></entry><entry><title>Новые команды в Linux для старых решений</title><link href="https://ipkalm.github.io/novye-komandy-v-linux-dlia-starykh-reshenii.html" rel="alternate"></link><published>2015-05-20T18:17:00+06:00</published><updated>2015-05-20T18:17:00+06:00</updated><author><name>ipkalm</name></author><id>tag:ipkalm.github.io,2015-05-20:novye-komandy-v-linux-dlia-starykh-reshenii.html</id><summary type="html">&lt;p&gt;Собственно копипаста &lt;a href="http://bneijt.nl/blog/post/new-linux-commands-for-old-habbits/"&gt;отсюда&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="netstat-ss"&gt;вместо &lt;em&gt;netstat&lt;/em&gt; используем &lt;em&gt;ss&lt;/em&gt;:&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ss -lpn
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="ifconfig-ip-addr"&gt;вместо &lt;em&gt;ifconfig&lt;/em&gt; используем &lt;em&gt;ip addr&lt;/em&gt;:&lt;/h3&gt;
&lt;p&gt;Раньше для вкл/выкл определенного интерфейса использовали&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ifconfig eth0 up
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;теперь так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ip link &lt;span class="nb"&gt;set &lt;/span&gt;dev eth0 up
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Для конфигурирования интерфейса:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ifconfig eth0 10.0.0.2/16
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;теперь:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ip addr dev eth0 add 10.0.0.2/16
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="ps-aux-grep-pgrep-af"&gt;вместо &lt;em&gt;ps aux | grep ...&lt;/em&gt; используем &lt;em&gt;pgrep -af&lt;/em&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ps aux &lt;span class="p"&gt;|&lt;/span&gt; grep rtorrent
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;теперь:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;pgrep -af rtorrent
&lt;/pre&gt;&lt;/div&gt;</summary><category term="linux"></category></entry><entry><title>Как выкачать сайт. wget</title><link href="https://ipkalm.github.io/kak-vykachat-sait-wget.html" rel="alternate"></link><published>2015-02-28T23:45:00+06:00</published><updated>2015-02-28T23:45:00+06:00</updated><author><name>ipkalm</name></author><id>tag:ipkalm.github.io,2015-02-28:kak-vykachat-sait-wget.html</id><summary type="html">&lt;p&gt;Для выкачки сайта при помощи wget над использовать сл ключи:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;wget -r -k -l &lt;span class="m"&gt;7&lt;/span&gt; -p -E -nc http://site.com/
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;-r  —    указывает на то, что нужно рекурсивно переходить по ссылкам на сайте, чтобы скачивать страницы.&lt;/p&gt;
&lt;p&gt;-k  —    используется для того, чтобы wget преобразовал все ссылки в скаченных файлах таким образом, чтобы по ним можно было переходить на локальном компьютере (в автономном режиме).&lt;/p&gt;
&lt;p&gt;-p  —    указывает на то, что нужно загрузить все файлы, которые требуются для отображения страниц (изображения, css и т.д.).&lt;/p&gt;
&lt;p&gt;-l  —    определяет максимальную глубину вложенности страниц, которые wget должен скачать (по умолчанию значение равно 5, в примере мы установили 7). В большинстве случаев сайты имеют страницы с большой степенью вложенности и wget может просто «закопаться», скачивая новые страницы. Чтобы этого не произошло можно использовать параметр -l.&lt;/p&gt;
&lt;p&gt;-E  —    добавлять к загруженным файлам расширение .html.&lt;/p&gt;
&lt;p&gt;-nc —    при использовании данного параметра существующие файлы не будут перезаписаны. Это удобно, когда нужно продолжить загрузку сайта, прерванную в предыдущий раз.&lt;/p&gt;
&lt;p&gt;--no-parent - не скачивать выше указанного каталога/ссылки.&lt;/p&gt;
&lt;p&gt;стырено &lt;a href="http://ru.najomi.org/_nix/wget"&gt;отсюда&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Некоторые сайты, например мне попался один вики-сайт, который таким образом выкачиватся не желал. Для такого сработала такая комбинация ключей:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;wget -k -p -r -l &lt;span class="m"&gt;1&lt;/span&gt; --restrict-file-names&lt;span class="o"&gt;=&lt;/span&gt;nocontrol,windows --html-extension &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;robots&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;off http://tralala.com
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Скорее всего это связано с шаблоном ссылок внутри сайта, http://.../index.php@some_page, но я не проверял.&lt;/p&gt;</summary><category term="linux"></category><category term="wget"></category></entry><entry><title>Диагностика hdd средствами unix</title><link href="https://ipkalm.github.io/diagnostika-hdd-sredstvami-unix.html" rel="alternate"></link><published>2015-02-09T22:08:00+06:00</published><updated>2015-02-09T22:08:00+06:00</updated><author><name>ipkalm</name></author><id>tag:ipkalm.github.io,2015-02-09:diagnostika-hdd-sredstvami-unix.html</id><summary type="html">&lt;p&gt;Здесь я опишу способы проверки hdd, стыренные из других источников, которые мне очень помогли понять, почему у меня тупит комп.&lt;/p&gt;
&lt;p&gt;Для теста &lt;em&gt;hdd&lt;/em&gt; использую 3 утилиты:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;smartctl из пакета smartmontools&lt;/li&gt;
&lt;li&gt;hdparm&lt;/li&gt;
&lt;li&gt;badblocks из пакета e2fsprogs&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Все тесты проводить на &lt;strong&gt;НЕ&lt;/strong&gt; смонтированном hdd.&lt;/p&gt;
&lt;h3 id="smartctl"&gt;smartctl:&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# smartctl -a /dev/sdX&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;отсюда интересует несколько параметров:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;5 Reallocated_Sector_Ct - указывает на количество использованных запасных блоков, заложенных "про запас" в случае когда hdd начинает сыпаться;&lt;/li&gt;
&lt;li&gt;9 Power_On_Hours - название говорит само за себя, сколько бедный hdd отмаслал часов;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="hdparm"&gt;hdparm:&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# hdparm -t /dev/sdX&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Команда покажет, скорость записи на hdd. Данную команду необходимо выполнить несколько раз, для б/м достоверной картины.&lt;/p&gt;
&lt;h3 id="badblocks"&gt;badblocks:&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# badblocks -vs /dev/sdX&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Команда с говорящим названием покажет, сколько битых блоком имеет поверхность hdd. Пояснение к ключам:&lt;/p&gt;
&lt;p&gt;-w — разрешает запись на жесткий диск, не заботясь о сохранности данных. &lt;strong&gt;Никогда не используйте для дисков, на которых есть нужная вам информация!&lt;/strong&gt; Несколько ускоряет тестирование.&lt;/p&gt;
&lt;p&gt;-v — выводит информацию об ошибках на экран.&lt;/p&gt;
&lt;p&gt;-s — выводит статус выполнения проверки в %. Для жесткого диска большого объема проверка может длиться несколько часов, поэтому, возможно, вам захочется наблюдать за ходом выполнения в процентах. Эта опция несколько замедляет работу утилиты, поэтому, если вы запускаете проверку, например, на ночь, эту опцию можно опустить.&lt;/p&gt;
&lt;p&gt;стырено &lt;a href="http://www.ubuntu.sumy.ua/2013/04/%D0%B4%D0%B8%D0%B0%D0%B3%D0%BD%D0%BE%D1%81%D1%82%D0%B8%D0%BA%D0%B0-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BE%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%B8-%D0%BF%D1%80%D0%BE.html"&gt;отсюда&lt;/a&gt;&lt;/p&gt;</summary><category term="linux"></category></entry><entry><title>Backup hdd средствами GNU/Linux</title><link href="https://ipkalm.github.io/backup-hdd-sredstvami-gnulinux.html" rel="alternate"></link><published>2015-02-09T19:30:00+06:00</published><updated>2015-02-09T19:30:00+06:00</updated><author><name>ipkalm</name></author><id>tag:ipkalm.github.io,2015-02-09:backup-hdd-sredstvami-gnulinux.html</id><summary type="html">&lt;p&gt;После теста hdd можно определить, пора ли менять диск или нет.&lt;/p&gt;
&lt;p&gt;Если время пришло, то тогда необходимо перенести со старого жесткого всю инфу на новый.&lt;/p&gt;
&lt;p&gt;Из гуглежа, стало ясно, чо использование обычного dd не "кошегно". Ъ использовать &lt;strong&gt;GNU ddrescue&lt;/strong&gt;. Команда для backup'а выглядит следующим образом:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# ddrescue /dev/sdX /pth_to_backup/disk.img /pth_to_backup/disk.img.log&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Можно делать backup как раздела, так и всего hdd.&lt;/p&gt;
&lt;p&gt;Для просмотра содержимого &lt;strong&gt;раздела&lt;/strong&gt; используем следующую команду:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# mount -o loop /pth_to_backup/drive.img /mnt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;А для &lt;strong&gt;образа физического диска&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# losetup --partscan /dev/loop0 drive.img&lt;/span&gt;
&lt;span class="c"&gt;# mount /dev/loop0p2 /mnt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;или,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# kpartx -a /dev/loop0 drive.img&lt;/span&gt;
&lt;span class="c"&gt;# mount /dev/mapper/loop0p2 /mnt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;в зависимости от дистра.&lt;/p&gt;
&lt;p&gt;Восстановление из образа:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# ddrescue --force disk.img /dev/sdxX disk.img.log&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;!!!&lt;strong&gt;раздел на который идет восстановление должен быть &lt;em&gt;НЕ&lt;/em&gt; меньше файла-образа&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;стырено &lt;a href="http://habrahabr.ru/post/233961/"&gt;изхабра&lt;/a&gt;&lt;/p&gt;</summary><category term="habr"></category><category term="linux"></category><category term="backup"></category></entry><entry><title>Сравнение каталогов в *unix. diff</title><link href="https://ipkalm.github.io/sravnenie-katalogov-v-unix-diff.html" rel="alternate"></link><published>2015-02-04T21:00:00+06:00</published><updated>2015-02-04T21:00:00+06:00</updated><author><name>ipkalm</name></author><id>tag:ipkalm.github.io,2015-02-04:sravnenie-katalogov-v-unix-diff.html</id><summary type="html">&lt;p&gt;Сравнение каталогов утилитой diff осуществляется следующим образом:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;diff -urN dir1 dir2  &amp;gt; out.diff


&lt;span class="nv"&gt;$ &lt;/span&gt;mc -e out.diff
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;где
ключи diff&lt;/p&gt;
&lt;p&gt;-u унифицированный метод&lt;/p&gt;
&lt;p&gt;-r рекурсивно &lt;/p&gt;
&lt;p&gt;-N При сравнении каталогов, если файл найден только в одном каталоге, считает что он находится и во втором, но является пустым. См. "Сравнение каталогов". &lt;/p&gt;
&lt;p&gt;Возможно использование 'diff' для сравнения некоторых или всех файлов в двух каталогах. Когда оба аргумента-имена файлов для 'diff' ­ каталоги, он сравнивает каждый файл, содержащийся в обоих каталогах, в алфавитном порядке имен файлов. Обычно 'diff' не упоминает о парах неотличающихся файлов, но с опцией '-s' или '--report-identical-files', он будет сообщать и о таких парах. Обычно 'diff' сообщает о подкаталогах, общих для обоих каталогов, не сравнивая файлы в них, но с помощью опции '-r' или '--recursive', он бужет сравнивать соответствующие файлы в дереве каталогов, опускаясь до самых глубоких каталогов.&lt;/p&gt;
&lt;p&gt;Для имен файлов, содержащихся только в одном каталоге, 'diff' обычно не показывает текста этих файлов, сообщая только, что файлы находятся в одном каталоге и отсутствуют в другом. Можно заставить 'diff' поступать так, как если бы соответствующие файлы существовали и в другом каталоге, но являлись пустыми, тогда в результатах будет присутствовать полный текст таких файлов. (Такие отличия будут рассматриваться как вставки или удаления, в зависимости от того существует файл в первой или второй директории.) Чтобы добиться этого используйте опцию '-N' или '--new-file'.&lt;/p&gt;
&lt;p&gt;Если в более старом каталоге содержится один или более больших файлов, не содержащихся в более новом, можно уменьшить patch с помощью опции '-P' или '--unidirectional-new-file' вместо '-N'. Эта опция подобна '-N', за исключением того, что она вставляет только содержимое файлов, появившихся во втором каталоге, а не в первом (т.е. добавленных файлов). В начале patch пишется инструкция для пользователей, применяющих patch, - стереть удаленные файлы, перед применением (см. подробнее о составлении patch-ей: "Составление patch-ей").&lt;/p&gt;
&lt;p&gt;Для игнорирования некоторых файлов при сравнении каталогов, используйте опцию '-x PATTERN' или '--exclude=PATTERN'. Эта опция игнорирует все файлы или поддиректории, чьи базовые имена соответствуют шаблону оболочки PATTERN. В отличие от оболочки, точка в начале имени файла рассматривается так же, как символ &lt;em&gt;. Следует заключать PATTERN в апострофы, чтобы оболочка не истоловала их неправильно. Например, опция '-x '&lt;/em&gt;.[ao]'' игнорирует все файлы, имена которых заканчиваются на '.a' или '.o'.&lt;/p&gt;
&lt;p&gt;Информация, указанная в этой опции, сохраняется, если ее использовать несколько раз. Например, использование опций '-x 'RCS' -x '*,v'' задает игнорирование всех файлов и подкаталогов, имеющих имя 'RCS' или заканчивающихся на ',v'.&lt;/p&gt;
&lt;p&gt;Если необходимо использовать эту опцию по несколько раз, можно вместо этого поместить шаблоны в файл, по одному на строку и использовать опцию '-X FILE' или '--exclude-from=FILE'.&lt;/p&gt;
&lt;p&gt;Если два каталога находились в процессе сравнения и этот процесс был прерван, позже возможно вернуться к сравнению и продолжить его с того же места с помощью опции '-S FILE' или '--starting-file=FILE'. После этого сравниваться будут только файл и FILE и следующеи за ним в алфавитном порядке, в верхнем уровне директории.&lt;/p&gt;
&lt;p&gt;Стырено с &lt;a href="http://rus-linux.net"&gt;rus-linux.net&lt;/a&gt; и &lt;a href="http://genaev.com"&gt;genaev.com&lt;/a&gt;&lt;/p&gt;</summary><category term="linux"></category><category term="diff"></category></entry></feed>